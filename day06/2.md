### AVL树的左右失衡与双旋转

首先，我们回顾一下AVL树的“铁律”：
**对于树中的任何一个节点，它的左子树和右子树的高度差，绝对不能超过1。**

**旋转不是随便挪节点，而是“指针重接”，必须保持二叉搜索树的中序顺序不变(中序遍历 = 左 → 根 → 右)**

当一次插入操作破坏了这个规矩，我们就必须通过“旋转”来恢复平衡。我们之前学习了简单的**单旋转**，它适用于“一边倒”的情况（LL或RR失衡）。但对于更复杂的“Z字形”失衡，单旋转会失灵。

#### 什么是“Z字形”失衡？

这就是我们今天要讲的**左右（LR）失衡**和**右左（RL）失衡**。它们的共同特点是，导致失衡的新节点，被插入到了**“内侧”**。
#### 右旋的“标准定义”

对节点 A 进行右旋，前提是：
```markdown

A 有左孩子 B
```

右旋规则只有两条：
```markdown

B 成为新的根

B 的右子树 → 挂到 A 的左子树
```
#### 左旋的“标准定义”

对节点 A 进行左旋，前提是：
```markdown

A 有右孩子 B
```

右旋规则只有两条：
```markdown

B 成为新的根

B 的左子树 → 挂到 A 的右子树
```


### 情况一：左右失衡 (Left-Right Imbalance)

*   **失衡形态**:
    1.  某个节点（我们叫它“祖父节点”`k3`）的**左边**太重了。
    2.  而导致左边太重的原因，是因为新节点被插在了左孩子的**右边**。

*   **比喻**: 想象`k3`是移动雕塑的总挂点。它的左边挂的串 `k1` 太长了，导致整个雕塑向左倾斜。但仔细一看，`k1`之所以长，是因为它下面挂的**右边**那个小串 `k2` 太重了。这就形成了一个 `k3 -> k1 -> k2` 的“Z”字形结构。

*   **图示**:
    ```markdown
         (k3)  <-- 高度差为2，失衡！
        /
      (k1)
        \
         (k2) <-- 新节点插在了这里或它的子树下
    ```

#### 为什么简单的“右旋”会失败？

如果我们试图对“祖父节点” `k3` 进行一次简单的右旋来修正，会发生什么？
`k1` 会被提上来当新根，`k3` 会成为它的右孩子。但是，`k2` 怎么办？它原来是 `k1` 的右孩子，现在依然是。

*   **单次右旋后的灾难性结果**:
    ```markdown
          (k1)
            \
             (k3)
            /
          (k2)
    ```
    你看，整个结构还是弯的！我们只是把一个“左边的Z字形”变成了“右边的Z字形”，树**依然是不平衡的**。

#### 正确的解决方案：双旋转（先左后右）

正确的做法是分两步，先把那个“胳膊肘”捋直，再进行整体的平衡。

**第1步：小范围的“左旋”，拉直胳膊肘**

*   **操作**: 我们先把目光聚焦在失衡的子树上，也就是以 `k1` 为根的部分。对 `k1` 进行一次**左旋转**。
*   **目的**: 把 `k2` 提上来，让 `k1` 成为它的左孩子。这样 `k3 -> k2 -> k1` 就成了一条直线。
*   **图示 (第一步之后)**:
    ```markdown
         (k3)  <-- 仍然失衡，但下面已经捋直了
        /
      (k2)
     /
   (k1)
    ```
    现在，我们把一个复杂的 **LR (左右)** 问题，成功转化成了一个简单的 **LL (左左)** 问题！

**第2步：大范围的“右旋”，完成最终平衡**

*   **操作**: 现在树的形态是我们熟悉的“左边一边倒”，我们对“祖父节点” `k3` 进行一次**右旋转**。
*   **目的**: 把 `k2` 提上来成为整个结构的根。
*   **图示 (最终平衡状态)**:
    ```markdown
          (k2)
         /    \
       (k1)  (k3)
    ```
    完美！现在这棵树重新满足了AVL的“铁律”。

### 情况二：右左失衡 (Right-Left Imbalance)

这和上面的情况完全是**镜像对称**的，逻辑一模一样。

*   **失衡形态**: 某个节点（`k1`）的**右边**太重了，原因是新节点插在了右孩子（`k3`）的**左边**（`k2`）。
*   **图示**:
    ```markdown
    (k1) <-- 失衡！
      \
       (k3)
      /
    (k2)
    ```

*   **解决方案：双旋转（先右后左）**
    1.  **第一步 (对`k3`右旋)**: 先对子树进行一次**右旋转**，把“胳膊肘”捋直，将 **RL** 问题转化为 **RR** 问题。
    2.  **第二步 (对`k1`左旋)**: 再对整体进行一次**左旋转**，完成最终的平衡。

*   **最终结果**:
    ```markdown
          (k2)
         /    \
       (k1)  (k3)
    ```

### C语言核心代码实现

在C语言中，双旋转并不是一个全新的函数，而是巧妙地**复用**了两个单旋转函数。

#### `DoubleRotateWithLeft` (处理 LR 左右失衡)

```c
// 这个函数用来修复 k3 的 LR (左右) 失衡
static Position DoubleRotateWithLeft(Position K3) {
    // 第1步: 对 K3 的左孩子(K1)进行一次“左旋”，把胳膊肘捋直
    // 这次旋转会把 K2 提上来
    K3->left = SingleRotateWithRight(K3->left);

    // 第2步: 现在整体变成了 LL 失衡，对 K3 进行一次“右旋”来最终修正
    return SingleRotateWithLeft(K3);
}
```

#### `DoubleRotateWithRight` (处理 RL 右左失衡)

```c
// 这个函数用来修复 K1 的 RL (右左) 失衡
static Position DoubleRotateWithRight(Position K1) {
    // 第1步: 对 K1 的右孩子(K3)进行一次“右旋”
    K1->right = SingleRotateWithLeft(K1->right);

    // 第2步: 现在整体变成了 RR 失衡，对 K1 进行一次“左旋”
    return SingleRotateWithRight(K1);
}
```

### 完整代码示例

下面是一个可以运行的 `main` 函数，专门用来演示 **LR 失衡** 的情况。

```c
#include <stdio.h>
#include <stdlib.h>

// --- (这里需要粘贴上一节课的 AvlNode 结构体定义, height, max, 
//      SingleRotateWithLeft, SingleRotateWithRight 函数) ---
// ... (此处省略，请确保已有这些基础函数)

// 插入函数，包含了处理四种失衡情况的逻辑
AvlTree insert(int data, AvlTree T) {
    if (T == NULL) {
        T = (AvlTree)malloc(sizeof(struct AvlNode));
        T->data = data;
        T->height = 0;
        T->left = T->right = NULL;
    } else if (data < T->data) {
        T->left = insert(data, T->left);
        if (height(T->left) - height(T->right) == 2) {
            if (data < T->left->data) // LL 情况
                T = SingleRotateWithLeft(T);
            else // LR 情况
                T = DoubleRotateWithLeft(T);
        }
    } else if (data > T->data) {
        T->right = insert(data, T->right);
        if (height(T->right) - height(T->left) == 2) {
            if (data > T->right->data) // RR 情况
                T = SingleRotateWithRight(T);
            else // RL 情况
                T = DoubleRotateWithRight(T);
        }
    }
    // 更新高度
    T->height = max(height(T->left), height(T->right)) + 1;
    return T;
}

// 辅助函数：打印树（前序遍历）
void printTree(AvlTree T) {
    if (T != NULL) {
        printf("%d ", T->data);
        printTree(T->left);
        printTree(T->right);
    }
}

int main() {
    AvlTree root = NULL;

    printf("--- 演示 LR 左右失衡 ---\n");
    printf("插入 30...\n");
    root = insert(30, root);
    printf("插入 10...\n");
    root = insert(10, root);
    
    printf("树的结构 (前序): ");
    printTree(root);
    printf("\n");
    printf("此时树是平衡的: 30(根), 10(左孩子)\n\n");
    
    printf("关键一步：插入 20...\n");
    printf("这将导致在节点30处出现 LR 失衡！\n");
    root = insert(20, root);
    
    printf("双旋转后，树的结构 (前序): ");
    printTree(root);
    printf("\n");
    printf("可以看到，20被提拔为新的根，树恢复了平衡！\n");

    return 0;
}
```

### 预期输出

```
--- 演示 LR 左右失衡 ---
插入 30...
插入 10...
树的结构 (前序): 30 10 
此时树是平衡的: 30(根), 10(左孩子)

关键一步：插入 20...
这将导致在节点30处出现 LR 失衡！
双旋转后，树的结构 (前序): 20 10 30 
可以看到，20被提拔为新的根，树恢复了平衡！
```