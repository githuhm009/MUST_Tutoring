### 二叉搜索树（BST）的删除操作

想象一下，一个二叉搜索树（BST）就是一个管理非常严格的公司。公司的规定是：
**“任何一个员工（节点），他左边下属（左子树）的工号，永远比他小；他右边下属（右子树）的工号，永远比他大。”**

现在，公司要**开除一个员工（删除一个节点）**。我们的任务是，在这个员工走后，调整组织架构，保证公司的这条“黄金规定”不被破坏。

#### C语言节点定义

首先，这是我们“员工”的设计图纸：
```c
// “员工”结构体的设计图纸
typedef struct TreeNode {
    int data;                 // 员工的工号
    struct TreeNode* left;    // 指向左边下属的指针
    struct TreeNode* right;   // 指向右边下属的指针
} TreeNode;
```
### 剧本一：开除一个“实习生”（删除叶子节点）

这是最简单的情况。被开除的员工没有任何下属。

*   **场景**: 要开除工号为 `4` 的员工。
*   **组织图**:
    ```markdown
        ...
         |
        (5) -- 父节点
       /
     (4) -- 要被开除的实习生 (左右下属都为 NULL)
    ```
*   **解决方案**: 非常简单，直接告诉他的上级（父节点）：“你手下这个叫 `4` 的人已经走了，你把他原来的位置（指针）标记为无人（`NULL`）就行了。”

*   **操作后**:
    ```markdown
        ...
         |
        (5) -- 父节点
       /
     NULL
    ```

### 剧本二：开除一个“小组长”（删除只有一个下属的节点）

情况稍微复杂一点。被开除的员工手下**只有一个**下属（或者只有一个左下属，或者只有一个右下属）。

*   **场景**: 要开除工号为 `5` 的员工，他只有一个右下属 `9`。
*   **组织图**:
    ```markdown
        ...
         |
        (7) -- 祖父节点
       /
     (5) -- 要被开除的小组长
       \
        (9) -- 唯一的下属
    ```
*   **解决方案**: “隔代提升”。直接让被开除员工的上级（`7`号），跳过被开除的人，直接管理他的那个唯一“孙子”（`9`号）。

*   **操作**: `7` 号的左指针，不再指向 `5` 号，而是直接指向 `9` 号。
    ```markdown
        ...
         |
        (7) -- 祖父节点
           \
            (9) -- “孙子”被提升，直接向祖父汇报
    ```
*   **别忘了**: `5` 号员工虽然在组织图上消失了，但他占用的办公室（内存）还在。我们需要调用 `free()` 把这块内存还给系统。

### 剧本三：开除一个“部门经理”（删除有两个下属的节点）

这是**最复杂、最核心**的情况。被开除的员工，既有左团队，又有右团队。你不能简单地让他消失，否则他手下两个团队就没人管了，公司就乱了。

*   **场景**: 要开除工号为 `2` 的经理。他左边管着 `1` 号，右边管着 `5` 号。
*   **组织图**:
    ```markdown
          (6)
         /
       (2) -- 要被开除的经理
      /   \
    (1)   (5)
         /
       (4)
    ```
*   **解决方案**: 公司规定，不能直接提拔 `1` 或者 `5`。为了维持稳定，必须找一个**“接班人”**。这个“接班人”有两个候选标准：
    1.  **右团队里工号最小的人 (右子树的最小值)**：他是右团队里最接近被开除经理的人，提拔他，对右团队影响最小。
    2.  **左团队里工号最大的人 (左子树的最大值)**：他是左团队里能力最强的，也能胜任。

    我们通常选择**标准1：右子树的最小值**。在上面的例子里，`2`号员工的右团队是 `(5)` 和 `(4)`，其中工号最小的是 `4` 号。所以，`4` 号就是“接班人”。

*   **操作步骤 (两步走)**:
    1.  **狸猫换太子**: 把“接班人” `4` 的工号，**复制**到要被开除的经理 `2` 的位置上。现在，`2` 号的位置实际上变成了 `4` 号在管理。
        ```markdown
              (6)
             /
           (4) -- 工号被替换了！
          /   \
        (1)   (5)
             /
           (4) -- “接班人”还在老位置
        ```
    2.  **删除“旧身份”**: 现在的问题变成了：如何删除原来那个 `4` 号员工？你看，`4` 号员工是一个**叶子节点**，删除它就转化成了我们最简单的**剧本一**！

*   **最终结果**:
    ```markdown
          (6)
         /
       (4) -- 新经理上任
      /   \
    (1)   (5) -- 新经理的右下属
    ```
**总结一下剧本三**: 删除一个有两个下属的节点，被巧妙地转化成了：
1.  找到它的“接班人”（右子树的最小值）。
2.  用接班人的数据**覆盖**掉要删除的节点。
3.  然后**递归地去删除**那个“接班人”节点（此时删除它就变成了剧本一或剧本二的问题）。

### C语言完整代码实现

```c
#include <stdio.h>
#include <stdlib.h>

// 节点（员工）的设计图纸
typedef struct TreeNode {
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

// 辅助函数：创建一个新节点（招聘一个新员工）
TreeNode* createNode(int data) {
    TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// 辅助函数：找到某个子树中的最小节点（找到团队里工号最小的人）
TreeNode* findMin(TreeNode* node) {
    // 只要有左下属，就一直往左走，因为左边的工号最小
    while (node && node->left != NULL) {
        node = node->left;
    }
    return node;
}

/**
 * 删除节点的核心函数
 * root: 当前公司的“CEO”
 * data: 要开除的员工工号
 * 返回值: 调整后的公司新“CEO”
 */
TreeNode* deleteNode(TreeNode* root, int data) {
    // 基本情况：公司是空的，或者找不到要开除的人
    if (root == NULL) {
        return root;
    }

    // 1. 先找到要开除的那个员工
    if (data < root->data) {
        // 如果要开除的人工号更小，说明他在左边团队，去左边找
        // 这句递归很关键：它会把删除后的新左子树，重新连接回父节点
        root->left = deleteNode(root->left, data);
    } else if (data > root->data) {
        // 如果工号更大，就去右边团队找
        root->right = deleteNode(root->right, data);
    } 
    // 2. 找到了！开始根据三个剧本进行操作
    else {
        // 剧本一：他是个“实习生”（没有下属，或只有一个下属）
        // 这个 if 聪明地同时处理了“没有下属”和“只有一个右下属”的情况
        if (root->left == NULL) {
            TreeNode* temp = root->right;
            free(root); // 开除他，释放办公室
            return temp; // 把他的唯一右下属（或NULL）交给他上级管理
        }
        // 这个 else if 处理了“只有一个左下属”的情况
        else if (root->right == NULL) {
            TreeNode* temp = root->left;
            free(root);
            return temp; // 把他的唯一左下属交给他上级管理
        }

        // 剧本三：他是个“部门经理”（有两个下属）
        // 1. 找到他的“接班人”（右团队里工号最小的那个）
        TreeNode* temp = findMin(root->right);

        // 2. “狸猫换太子”：用接班人的工号覆盖掉当前经理的工号
        root->data = temp->data;

        // 3. “删除旧身份”：现在去他的右团队里，把那个“接班人”开除掉
        //    因为我们已经知道“接班人”没有左下属，所以这次递归删除会很简单
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}

// 辅助函数：中序遍历打印树（按工号从小到大打印员工名单）
void inorderTraversal(TreeNode* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->data);
        inorderTraversal(root->right);
    }
}

// 主函数：演示整个过程
int main() {
    // 建立一个公司组织架构
    TreeNode* root = createNode(50);
    root->left = createNode(30);
    root->right = createNode(70);
    root->left->left = createNode(20);
    root->left->right = createNode(40);
    root->right->left = createNode(60);
    root->right->right = createNode(80);

    printf("公司初始人员 (按工号排序): ");
    inorderTraversal(root);
    printf("\n\n");

    // --- 演示剧本一：开除实习生 20 ---
    printf("准备开除工号为 20 的员工 (叶子节点)...\n");
    root = deleteNode(root, 20);
    printf("开除后的人员名单: ");
    inorderTraversal(root);
    printf("\n\n");

    // --- 演示剧本二：开除小组长 30 ---
    printf("准备开除工号为 30 的员工 (只有一个下属)...\n");
    root = deleteNode(root, 30);
    printf("开除后的人员名单: ");
    inorderTraversal(root);
    printf("\n\n");

    // --- 演示剧本三：开除部门经理 50 ---
    printf("准备开除工号为 50 的员工 (有两个下属)...\n");
    root = deleteNode(root, 50);
    printf("开除后的人员名单: ");
    inorderTraversal(root);
    printf("\n");

    return 0;
}
```

### 预期输出

```
公司初始人员 (按工号排序): 20 30 40 50 60 70 80 

准备开除工号为 20 的员工 (叶子节点)...
开除后的人员名单: 30 40 50 60 70 80 

准备开除工号为 30 的员工 (只有一个下属)...
开除后的人员名单: 40 50 60 70 80 

准备开除工号为 50 的员工 (有两个下属)...
开除后的人员名单: 40 60 70 80 
```
从输出可以看到，每次删除后，中序遍历的结果依然是**有序的**，这证明我们成功地维持了二叉搜索树的“黄金规定”！