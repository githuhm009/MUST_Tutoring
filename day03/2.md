### 第三章代码讲解

我们还是把这整套代码看作是**从零开始建造和管理一列火车**。

### Part 1: 设计和建造单个火车车厢

#### `struct Node` - 火车车厢的设计图纸

```c
struct Node {
    int data;           // 这是车厢里装的“货物”
    struct Node* next;  // 这是连接下一节车厢的“挂钩”
};
```
*   这几行代码是一个**设计图**，规定了每一节“车厢”（`Node`）都必须包含：
    1.  `data`：用来放货物（一个整数）。
    2.  `next`：一个特殊的“挂钩”，能**记住下一节车厢的位置（地址）**。

#### `createNode` - 建造一节新车厢的工厂

```c
struct Node* createNode(int new_data) {
    // 1. 向系统申请一块空地，大小刚好能造一节车厢
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    // 2. 把货物 new_data 装进这节新车厢里
    new_node->data = new_data;
    // 3. 新车厢的挂钩暂时不连任何东西 (NULL)
    new_node->next = NULL;
    // 4. 把这节新车厢的“钥匙”（内存地址）交出去
    return new_node;
}
```
*   这是一个**车厢制造工厂**。你给它一个货物，它就用 `malloc` 造一节全新的、独立的车厢，然后把这节车厢的地址返回给你。

---

### Part 2: 查看和组装火车

#### `traverseLinkedList` - 火车巡检员

```c
void traverseLinkedList(struct Node* head) {
    // 1. 派一个叫 current 的“巡检员”，让他从火车头(head)开始
    struct Node* current = head;
    // 2. 只要还没走出火车（还没遇到NULL），就一直走下去
    while (current != NULL) {
        // 3. 每到一节车厢，就报出里面的货物
        printf("%d -> ", current->data);
        // 4. 然后通过“挂钩”走到下一节车厢
        current = current->next;
    }
    // 5. 走完所有车厢后，报告“巡检结束”
    printf("null\n");
}
```
*   这个函数的作用就是**从头到尾走一遍火车，并报告每节车厢的货物**。`current = current->next;` 是最关键的一步，意思是“去往挂钩所指向的下一节车厢”。

#### `main` 函数 - 手动组装火车

```c
int main() {
    // 造出第一节车厢(火车头)，货物是1
    struct Node* head = createNode(1);
    // 把第二节车厢(货物2)挂在火车头的后面
    head->next = createNode(2);
    // 把第三节车厢(货物3)挂在第二节车厢的后面
    head->next->next = createNode(3);
    // 把第四节车厢(货物4)挂在第三节车厢的后面
    head->next->next->next = createNode(4);

    // 叫巡检员来检查一下我们刚组装好的火车
    traverseLinkedList(head);
    return 0;
}
```
*   这展示了最原始的组装方式：
    *   `head->next` 的意思是“火车头的挂钩”。我们让它指向新造的第二节车厢。
    *   `head->next->next` 的意思是“火车头的下一节车厢的挂钩”，我们让它指向新造的第三节车厢。

---

### Part 3: 在火车上找东西

#### `searchNode` - 按货物查找车厢

```c
int searchNode(struct Node* head, int target) {
    int position = 1;         // 从1号车厢开始数
    struct Node* current = head; // 巡检员从火车头出发
    while (current != NULL) {   // 只要还没走完火车
        if (current->data == target) { // 如果当前车厢的货物正好是要找的
            return position; // 立刻报告车厢编号！
        }
        current = current->next; // 否则，去下一节车厢
        position++;              // 并且车厢编号加一
    }
    return -1; // 走完了都没找到，报告-1
}
```
*   这个函数就像一个侦探，他从头开始，一节一节地检查，同时自己数着这是第几节车厢。找到就报告编号，找不到就报告-1。

---

### Part 4: 更智能地管理火车

#### `insertNode` - 在指定位置加一节新车厢

```c
struct Node* insertNode(struct Node* head, int position, int data) {
    // 先把要加的新车厢造好
    struct Node* newNode = createNode(data);

    // 情况一：在最前面（1号位置）加，也就是换个新的火车头
    if (position == 1) {
        newNode->next = head; // 新车厢的挂钩，连接到旧的火车头
        return newNode;       // 告诉所有人，新的火车头是这个newNode
    }

    // 情况二：在中间或末尾加
    struct Node* current = head; // 巡检员从火车头出发
    // 让他走到要插入位置的“前一节”车厢
    for (int i = 1; i < position - 1 && current != NULL; ++i) {
        current = current->next;
    }
    
    // 如果火车没那么长，是个无效位置
    if (current == NULL) { return head; /* 啥也不干，返回原样 */ }

    // 开始“接挂钩”的关键操作
    newNode->next = current->next; // 1. 新车厢先连接后面的车厢
    current->next = newNode;       // 2. 前面的车厢再连接新车厢
    
    return head; // 火车头没变，返回旧的火车头
}
```
*   **特殊情况**：在第1位插入，意味着火车头换了，所以函数必须返回**新的火车头地址**。
*   **普通情况**：要先走到**目标位置的前一个**位置。然后执行两步连接操作。

#### `deleteNode` - 在指定位置拆掉一节车厢

```c
struct Node* deleteNode(struct Node* head, int position) {
    // 如果火车是空的，直接返回
    if (head == NULL) return NULL;

    struct Node* temp; // 用来临时存放要被拆掉的车厢

    // 情况一：拆掉火车头
    if (position == 1) {
        temp = head;            // 记住旧火车头
        head = head->next;      // 让第二节车厢成为新的火车头
        free(temp);             // 把旧火车头送去“回收站”
        return head;            // 返回新的火车头
    }
    
    // 情况二：拆掉中间或末尾的车厢
    struct Node* current = head; // 巡检员出发
    // 走到要被拆掉的车厢的“前一节”
    for (int i = 1; i < position - 1 && current != NULL; i++) {
        current = current->next;
    }

    // 如果位置无效，或者要拆的是最后一节的后面，就啥也不干
    if (current == NULL || current->next == NULL) return head;

    // 开始“拆卸”操作
    temp = current->next; // 记住要被拆掉的车厢
    current->next = temp->next; // 前一节车厢“跨过”被拆的车厢，直接连接到后一节
    free(temp); // 把被拆掉的车厢送去“回收站”

    return head;
}
```
*   这段代码用了两个“巡检员”指针来配合：`currentNode` 勇往直前，走到要删除的目标上；`temp` 紧随其后，始终保持在 `currentNode` 的前一个位置。
*   删除的关键就是让 `temp` 这个“前一节车厢”的挂钩，指向 `currentNode` 这个“待删车厢”的下一节。

---

### Part 5: 回顾一下数组

这部分代码是用来对比的，意思是“在学开火车之前，我们先看看开汽车是啥样的”。

#### `staticArray` - 固定长度的停车场

```c
int staticArray[] = {1, 2, 3, 4, 5};
int length = sizeof(staticArray) / sizeof(staticArray[0]);
```
*   这就像建一个**大小完全固定**的停车场。一旦建好（程序编译好），车位的数量就再也不能变了。
*   `sizeof(staticArray)` 是计算整个停车场占地多大。
*   `sizeof(staticArray[0])` 是计算一个车位占地多大。
*   两者相除，就得到了有多少个车位。这是一种C语言里常用的技巧。

#### `dynamicArray` - 可伸缩的临时停车场

```c
int size = 5;
int *dynamicArray = (int *)malloc(size * sizeof(int));
for (int i = 0; i < size; i++) {
    scanf("%d", &dynamicArray[i]);
}
```
*   这就像**临时租用**一块停车场。
*   `size = 5`：你先想好需要多少个车位。
*   `malloc(...)`：然后你跟管理员 (`malloc`) 说：“我要一块能停 `size` 辆车的连续空地”。管理员给你这块地的起始地址，你用 `dynamicArray` 这个指针记下来。
*   这种方式更灵活，因为 `size` 的值可以在程序运行时再决定。
*   虽然它叫“动态数组”，但一旦用 `malloc` 申请下来，这块空间的大小也是**暂时固定**的，它和链表那种“随时加一节”的动态性是不同的。