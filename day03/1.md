# 数组查找 vs. 链表查找

想象一下，你要在一栋楼里找一个人。这栋楼有两种不同的设计，分别对应着数组和链表。

## 1. 数组查找：按门牌号找人的公寓楼

数组就像一栋设计规整的**公寓楼**。

*   **特点**: 所有房间（内存单元）都是**紧挨着**的，并且每个房间都有一个**明确的门牌号**（这就是**索引** `index`）。
*   **查找方式**: 如果有人告诉你，你要找的人住在 **502** 房。你根本不需要从101房开始挨家挨户地问。你可以直接坐电梯到5楼，然后找到2号房间。这是一步到位的操作。

在C语言中，当你写 `my_array[4]` 时，你就是在告诉电脑：“直接去公寓楼的第4号房间，把里面的东西拿出来。” 电脑的计算很简单：`楼的起始地址 + 4 * 每个房间的大小`，瞬间就能定位。

### 按位置查找 (O(1) - 飞一样的快)

如果你知道你要找的是“第 `i` 个”元素，用数组查找是最高效的。

```c
#include <stdio.h>

// 假设我们有一个传感器读数的数组
int sensor_readings[] = {25, 26, 28, 27, 30, 29};

// 任务：获取第4个传感器的读数 (索引为3)
int get_reading_by_position(int position_index) {
    // 就像直接去公寓的指定房间号
    return sensor_readings[position_index];
}

int main() {
    int reading = get_reading_by_position(3);
    printf("第4个传感器的读数是: %d\n", reading); // 输出 27
    return 0;
}
```
这个过程，不管数组有10个元素还是100万个元素，都只是一次计算，速度极快。我们称之为O(1)，即常数时间复杂度。

### 按内容查找 (O(n) - 只能挨个找)

但是，如果你不知道门牌号，只知道你要找的人叫“张三”，那怎么办？即使是在公寓楼里，你也只能从第一个房间开始，挨家挨户地敲门问：“请问你叫张三吗？” 直到找到为止。

```c
// 任务：在所有读数中，查找值为30的读数在哪个位置
int find_position_by_value(int target_value) {
    int total_readings = 6;
    for (int i = 0; i < total_readings; i++) {
        // 挨家挨户地比较
        if (sensor_readings[i] == target_value) {
            return i; // 找到了，返回它的“门牌号”
        }
    }
    return -1; // 找遍了所有房间，没找到
}
```

## 2. 链表查找：寻宝游戏

链表就像一场精心设计的**寻宝游戏**。

*   **特点**: 藏宝的地点（节点）是**零散分布**在各处的。你手上只有**第一张藏宝图**的线索（`head` 指针）。
*   **查找方式**: 你无法直接跳到第五个藏宝点。你必须先根据第一张图的指示，找到第二个藏宝点；再打开第二个点的锦囊，根据里面的指示找到第三个点……以此类推。这个过程必须**一步一步，顺序进行**。

在C语言中，`head->next` 就是“下一个藏宝点的地址”。你必须不断地 `current = current->next;` 才能在链条上前进。

### 查找，无论按位置还是按内容 (O(n) - 只能一步一步走)

在链表的世界里，**不存在“一步到位”的查找**。你想找“第5个”节点，对不起，请从第一个节点开始，一步、两步、三步、四步地走过去。你想找“数据是30”的节点，同样对不起，也得从第一个开始，一个个地拆开看。

```c
#include <stdio.h>
#include <stdlib.h>

// (这里省略了上一章的 Node 定义和 createNode 函数)
// struct Node { int data; struct Node* next; };

// 任务：在链表中查找值为30的节点
struct Node* find_node_by_value(struct Node* head, int target_value) {
    struct Node* current = head; // 从第一个线索开始

    // 只要还没到游戏终点 (NULL)，就继续
    while (current != NULL) {
        // 检查当前这个藏宝点的数据是不是想要的
        if (current->data == target_value) {
            return current; // 找到了！
        }
        // 如果不是，就根据当前线索去下一个地点
        current = current->next;
    }

    return NULL; // 所有线索都走完了，还是没找到
}
```
这个过程，如果链表有 `n` 个节点，最坏的情况下你需要走 `n` 步。我们称之为O(n)，即线性时间复杂度。


## 核心区别总结

| 特性 | 数组 (公寓楼) | 链表 (寻宝游戏) |
| :--- | :--- | :--- |
| **查找方式** | **直接访问** (Direct Access) | **顺序访问** (Sequential Access) |
| **按位置查找**| **O(1)** - 极快，直接“传送” | **O(n)** - 慢，必须从头走n步 |
| **按内容查找**| **O(n)** - 必须挨个敲门比较 | **O(n)** - 必须挨个拆开锦囊比较 |
| **根本原因**| 内存是**连续的、有编号的** | 内存是**分散的，靠指针链接** |

**一句话总结**：
数组查找的优势在于，如果你知道“门牌号”（索引），找人就飞快。而链表不管你要找什么，都必须从第一个人开始问路，老老实实地走过去。