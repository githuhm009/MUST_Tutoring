### 数组实现队列的基础与核心优化

我们今天要学习如何用数组来模拟一个“队列”，就像一个排队买票的队伍。队列的规矩是**“先进来的，先出去”（First-In, First-Out, FIFO）**。

#### 1. 最初的“笨”方法：大家一起向前挪

如果我们用最直接的想法，用一个普通数组来当队伍，会发生什么？

*   **入队 (Enqueue)**: 很简单，新来的人站到队伍的最后面。这很高效。
*   **出队 (Dequeue)**: 问题来了。队首的人（在数组索引`0`的位置）买完票走了。为了保持队伍的整齐，排在第2位的人必须挪到第1位，第3位挪到第2位……队伍里的每一个人都要**向前挪动一个位置**。

**这就是那个“痛点”**：如果队伍有一千个人，一个人出队，后面的999个人都要动一下。这太浪费时间了！在程序里，这个“挪动”操作就是一个 `for` 循环，它的时间复杂度是 `O(n)`，意味着队伍越长，效率越低。

#### 2. 核心优化：从“挪人”到“挪动头尾标记”

为了解决上面那个效率极低的“挪人”问题，我们引入一套全新的、聪明的管理规则。想象一下，我们的队伍不再是人在动，而是在一个长长的走廊（数组）里，我们只移动两个标记：“队头在这里”和“队尾在这里”。

为此，我们需要一个“管理员”结构体，他需要记住三件事：

```c
struct Queue {
    int front;    // “队头”标记，指向队伍里第一个元素的位置
    int rear;     // “队尾”标记，指向下一个新人应该站的位置
    int size;     // 一个计数器，时刻记录着队伍里到底有多少人
    int capacity; // 走廊（数组）的总容量
    int* array;   // 走廊（数组）本身
};
```

**新的游戏规则如下：**

1.  **`size` 说了算**: 我们不再通过 `rear - front` 这种复杂的方式计算队伍长度。`size` 变量直接、准确地告诉我们队伍里有多少人。
2.  **`front` 指挥出队**: 当一个人要出队时，我们**根本不碰数组里的任何数据**！我们只需要：
    *   把 `front` 标记向后移动一个位置。
    *   把 `size` 减 1。
    这就“逻辑上”完成了出队。那个旧的队首元素虽然还在数组里，但我们已经不认为它在队伍里了。这个操作只动了两个变量，瞬间完成，时间复杂度是 O(1)！
3.  **`rear` 指挥入队**: 当一个人要入队时，他走到 `rear` 标记指示的空位站好，然后 `rear` 标记向后移动一个位置，同时 `size` 加 1。

**这个聪明的优化，引出了一个更高级的概念——循环队列 (Circular Queue)。**

因为 `front` 和 `rear` 标记不断向后移动，走廊的尽头很快就用完了。怎么办？很简单，让它们“绕”回来！如果 `rear` 走到了数组的最后一个位置，它的下一个位置就应该是数组的开头 `0`。这个“绕圈”的操作，用一个简单的数学技巧就能实现：取模运算 (`%`)。

---

### C语言完整代码实现

下面是这个“聪明”队列的完整实现，包括主函数和详细注释。

```c
// 文件名: circular_queue_array.c

#include <stdio.h>
#include <stdlib.h>
#include <limits.h> // 为了使用 INT_MIN

// “管理员”结构体的设计图纸
struct Queue {
    int front, rear; // 队头和队尾的标记 (索引)
    int size;        // 队列中当前的元素数量
    int capacity;    // 队列的总容量
    int* array;      // 存放元素的数组 (走廊)
};

// 工厂函数：创建一个新的、空的队列
struct Queue* createQueue(int capacity) {
    // 1. 创建管理员办公室
    struct Queue* queue = (struct Queue*)malloc(sizeof(struct Queue));
    // 2. 设置总容量
    queue->capacity = capacity;
    // 3. 初始时，队头在0号位，队伍里没人
    queue->front = queue->size = 0;
    // 4. 队尾标记也从0号位开始 (下一个新人站的位置)
    queue->rear = 0;
    // 5. 创建用来排队的数组空间
    queue->array = (int*)malloc(queue->capacity * sizeof(int));
    return queue;
}

// 辅助函数：判断队列是否已满
int isFull(struct Queue* queue) {
    return (queue->size == queue->capacity);
}

// 辅助函数：判断队列是否为空
int isEmpty(struct Queue* queue) {
    return (queue->size == 0);
}

/**
 * 入队操作 (Enqueue)
 * 功能: 在队尾添加一个新元素
 */
void enqueue(struct Queue* queue, int item) {
    if (isFull(queue)) {
        printf("队列已满，%d 无法入队!\n", item);
        return;
    }
    // 1. 新人站到 `rear` 指示的空位上
    queue->array[queue->rear] = item;
    // 2. `rear` 标记向后移动一位，准备给下下个新人
    //    这里的 % capacity 就是实现“绕圈”的关键！
    queue->rear = (queue->rear + 1) % queue->capacity;
    // 3. 队伍总人数加 1
    queue->size = queue->size + 1;
    printf("%d 已入队。当前人数: %d, 队头位置: %d, 队尾位置: %d\n", item, queue->size, queue->front, queue->rear);
}

/**
 * 出队操作 (Dequeue)
 * 功能: 移除并返回队首的元素
 */
int dequeue(struct Queue* queue) {
    if (isEmpty(queue)) {
        printf("队列为空，无法出队!\n");
        return INT_MIN; // 返回一个错误值
    }
    // 1. 记下队首元素的值，准备返回
    int item = queue->array[queue->front];
    // 2. “队头”标记向后移动一位，同样用 % capacity 实现绕圈
    //    这就是高效的 O(1) 出队操作！
    queue->front = (queue->front + 1) % queue->capacity;
    // 3. 队伍总人数减 1
    queue->size = queue->size - 1;
    printf("%d 已出队。当前人数: %d, 队头位置: %d, 队尾位置: %d\n", item, queue->size, queue->front, queue->rear);
    return item;
}

// 主函数：展示队列如何工作
int main() {
    // 创建一个容量为5的队列
    struct Queue* queue = createQueue(5);

    printf("--- 开始操作 ---\n");
    enqueue(queue, 10);
    enqueue(queue, 20);
    enqueue(queue, 30);
    enqueue(queue, 40);

    printf("\n--- 进行一次出队 ---\n");
    dequeue(queue);

    printf("\n--- 继续入队 ---\n");
    enqueue(queue, 50);
    enqueue(queue, 60); // 这次会触发“绕圈”

    printf("\n--- 再次尝试入队 ---\n");
    enqueue(queue, 70); // 这次会因为队列已满而失败

    printf("\n--- 清空队列 ---\n");
    while (!isEmpty(queue)) {
        dequeue(queue);
    }
    
    // 释放内存
    free(queue->array);
    free(queue);

    return 0;
}
```

### 预期输出

```
--- 开始操作 ---
10 已入队。当前人数: 1, 队头位置: 0, 队尾位置: 1
20 已入队。当前人数: 2, 队头位置: 0, 队尾位置: 2
30 已入队。当前人数: 3, 队头位置: 0, 队尾位置: 3
40 已入队。当前人数: 4, 队头位置: 0, 队尾位置: 4

--- 进行一次出队 ---
10 已出队。当前人数: 3, 队头位置: 1, 队尾位置: 4

--- 继续入队 ---
50 已入队。当前人数: 4, 队头位置: 1, 队尾位置: 0
60 已入队。当前人数: 5, 队头位置: 1, 队尾位置: 1

--- 再次尝试入队 ---
队列已满，70 无法入队!

--- 清空队列 ---
20 已出队。当前人数: 4, 队头位置: 2, 队尾位置: 1
30 已出队。当前人数: 3, 队头位置: 3, 队尾位置: 1
40 已出队。当前人数: 2, 队头位置: 4, 队尾位置: 1
50 已出队。当前人数: 1, 队头位置: 0, 队尾位置: 1
60 已出队。当前人数: 0, 队头位置: 1, 队尾位置: 1
```

从输出中你可以清晰地看到 `front`, `rear`, `size` 是如何变化的，特别是当 `rear` 从4变回0时，“绕圈”的效果就体现出来了，从而高效地复用了数组开头的空间。