### 核心概念：什么是“栈”？

想象一摞盘子，或者一筒薯片。

*   **放盘子（Push）**: 你只能把新盘子放在**最上面**。
*   **拿盘子（Pop）**: 你也只能从**最上面**拿走一个盘子。
*   **看一眼（Peek）**: 你只能看到**最上面**那个盘子的花色。

这个规则——**“后进来的，先出去”（Last-In, First-Out, LIFO）**——就是栈的唯一核心思想。

在C语言里，没有现成的“栈”这种东西。但没关系，我们可以用已有的工具——数组和链表——来**模拟**一个栈。关键在于，我们只使用它们的一部分功能，并**人为地加上“只能在顶端操作”的规矩**。

### 方法一：用数组实现栈（像一个固定高度的书架）

这是最直观的实现方式。我们把数组想象成一个**有固定高度的书架**。

#### 1. 设计图纸：`struct Stack`

我们需要一个“管理员”来管理这个书架，他需要知道三件事：

```c
struct Stack {
    int top;             // 一个“书签”，永远指向最顶上那本书的位置
    unsigned capacity;   // 书架的总容量（能放多少本书）
    int* array;          // 书架本身（用来放书的数组）
};
```
*   `capacity`: 书架的总高度，一开始就定好了。
*   `array`: 指向我们用来当书架的那块内存。
*   `top`: 这是管理员的**核心工具**。我们约定，当书架为空时，`top` 指向 `-1`。每放一本书，`top` 就往上移一格。

#### 2. 工厂函数：`createStack`

这个函数负责建造一个全新的、空的书架。

```c
struct Stack* createStack(unsigned capacity) {
    // 1. 先造一个“管理员办公室”（Stack结构体）
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    // 2. 记下这个书架的容量
    stack->capacity = capacity;
    // 3. 刚开始书架是空的，所以“书签”放在-1的位置
    stack->top = -1;
    // 4. 根据容量，用malloc申请一整块内存来当书架
    stack->array = (int*)malloc(stack->capacity * sizeof(int));
    // 5. 把这个全新的书架管理员交出去
    return stack;
}
```

#### 3. 辅助函数：`isFull` 和 `isEmpty`

这两个函数是管理员用来判断书架状态的。
*   `isFull`: 书满了么？—— “看看‘书签’的位置是不是已经到了书架的最高处 (`capacity - 1`)”。
*   `isEmpty`: 书是空的么？—— “看看‘书签’是不是还在初始的 `-1` 位置”。

#### 4. 核心操作：`push`, `pop`, `peek`

*   **`push` (放一本书在顶上)**
    ```c
    void push(struct Stack* stack, int item) {
        // 如果书架满了，就啥也不干
        if (isFull(stack)) return;
        // 关键：先把“书签”往上移一格，然后把新书放在那个位置
        stack->array[++stack->top] = item;
    }
    ```
    `++stack->top` 这个写法很巧妙，是“先自增，再使用”的意思。

*   **`pop` (从顶上拿走一本书)**
    ```c
    int pop(struct Stack* stack) {
        // 如果书架是空的，没书可拿，就返回一个特殊值
        if (isEmpty(stack)) return INT_MIN;
        // 关键：返回“书签”当前位置的书，然后把“书签”往下移一格
        return stack->array[stack->top--];
    }
    ```
    `stack->top--` 是“先使用，再自减”。注意，我们并没有真的去“擦掉”数组里的数据，只是移动了书签，旧的数据以后会被新的 `push` 覆盖掉。

*   **`peek` (看一眼顶上的书)**
    ```c
    int peek(struct Stack* stack) {
        if (isEmpty(stack)) return INT_MIN;
        // 只看不拿，所以只返回书的内容，不动“书签”
        return stack->array[stack->top];
    }
    ```

#### 5. 优缺点总结

*   **优点**: 实现简单，因为内存是连续的，访问快。没有额外的指针开销，省内存。
*   **缺点**: **大小固定**。书架建多高，程序一开始就得定死。如果实际放的书很少，就浪费了空间；如果书太多，书架会“爆掉”（溢出）。

### 方法二：用链表实现栈（像一串可以无限加的糖葫芦）

链表天然就是动态的，非常适合用来实现一个“永不装满”的栈。我们把**链表的头部**当作**栈的顶部**。

#### 1. 设计图纸：`struct StackNode`

这次我们不需要“管理员”了，因为链表自己就能管理自己。我们的“车厢”设计图就够了。

```c
struct StackNode {
    int data;                 // 糖葫芦上的山楂
    struct StackNode* next;   // 串下一个山楂的竹签
};
```
这就是我们之前学的链表节点，换了个名字而已。

#### 2. 工厂函数：`newNode`

和 `createNode` 一模一样，就是造一个独立的、新的节点（一颗新的山楂）。

#### 3. 核心操作：`push` 和 `pop`

*   **`push` (在最顶上加一颗新山楂)**
    这和我们之前学的**“在链表头部插入一个新节点”**的操作是**完全一样**的！

    ```c
    void push(struct StackNode** root, int data) {
        // 1. 先造一颗新山楂
        struct StackNode* stackNode = newNode(data);
        // 2. 新山楂的竹签，指向原来最顶上的那颗山楂
        stackNode->next = *root;
        // 3. 更新“顶”的标记，让它指向这颗新山楂
        *root = stackNode;
    }
    ```
    **最难理解的地方：`struct StackNode** root`** (指针的指针)
    *   `root` 是 `main` 函数里那个指向“第一颗山楂”的指针。
    *   `push` 函数需要改变 `main` 函数里 `root` 的值（让它指向新山楂）。
    *   如果你只传 `struct StackNode* root`，函数得到的是一个**地址的副本**，修改它不会影响 `main` 函数里的原版。
    *   所以我们必须传递 `root` 指针**本身的地址**（`&root`），也就是“指针的指针”。函数通过 `*root` 来解引用，拿到并修改 `main` 函数里的原版 `root` 指针。

*   **`pop` (吃掉最顶上的一颗山楂)**
    这和我们之前学的**“删除链表的头节点”**的操作是**完全一样**的！

    ```c
    int pop(struct StackNode** root) {
        if (isEmpty(*root)) return INT_MIN;
        // 1. 用一个临时指针 temp 记住要被吃掉的这颗山楂
        struct StackNode* temp = *root;
        // 2. 更新“顶”的标记，让它指向下一颗山楂
        *root = (*root)->next;
        // 3. 把这颗山楂的数据取出来，准备返回
        int popped = temp->data;
        // 4. 把这颗山楂占用的内存还给系统
        free(temp);
        // 5. 返回吃掉的山楂的数据
        return popped;
    }
    ```
    这里同样需要用 `**root`，因为我们要修改 `main` 函数里的 `root` 指针。

#### 完整代码示例

```c

#include <stdio.h>    // 用于 printf 函数
#include <stdlib.h>   // 用于 malloc 和 free 函数
#include <limits.h>   // 用于 INT_MIN, 表示一个错误值

// “糖葫芦”上每个山楂的设计图纸
struct StackNode {
    int data;                // 山楂里的数据
    struct StackNode* next;  // 串下一个山楂的竹签
};

// 工具函数：判断糖葫芦串是否为空
// 如果“顶端”（root）什么都没指向，那就是空的
int isEmpty(struct StackNode* root) {
    return root == NULL;
}

// 工厂函数：造一颗新的、独立的山楂
struct StackNode* newNode(int data) {
    // 1. 申请一块内存，刚好放一颗山楂
    struct StackNode* stackNode = (struct StackNode*)malloc(sizeof(struct StackNode));
    // 2. 把数据放进去
    stackNode->data = data;
    // 3. 它的竹签暂时不串任何东西
    stackNode->next = NULL;
    // 4. 返回这颗新造好的山楂
    return stackNode;
}

/**
 * 压栈操作 (Push)
 * 功能: 在糖葫芦串的最顶上加一颗新山楂
 * 参数: root - 指向“顶端山楂指针”的指针，因为我们要修改它
 *       data - 新山楂里的数据
 */
void push(struct StackNode** root, int data) {
    // 1. 先造一颗新山楂
    struct StackNode* stackNode = newNode(data);
    
    // 2. 新山楂的竹签，指向原来最顶上的那颗山楂 (*root 就是原来的顶)
    stackNode->next = *root;
    
    // 3. 更新“顶端”的标记，让它指向这颗新山楂
    //    这样，新山楂就正式成为了新的“顶”
    *root = stackNode;
    
    printf("%d 被压入栈 (push)\n", data);
}

/**
 * 出栈操作 (Pop)
 * 功能: 吃掉并返回最顶上的一颗山楂
 * 参数: root - 指向“顶端山楂指针”的指针，因为我们要修改它
 */
int pop(struct StackNode** root) {
    // 如果串是空的，没得吃，就返回一个特殊的错误值
    if (isEmpty(*root)) {
        printf("栈为空，无法出栈 (pop)!\n");
        return INT_MIN;
    }
    
    // 1. 用一个临时指针 temp 记住要被吃掉的这颗山楂（也就是当前的顶）
    struct StackNode* temp = *root;
    
    // 2. 更新“顶端”的标记，让它指向下一颗山楂
    //    这样，第二颗山楂就成为了新的“顶”
    *root = (*root)->next;
    
    // 3. 把这颗山楂的数据取出来，准备返回
    int popped = temp->data;
    
    // 4. 把这颗被吃掉的山楂占用的内存还给系统，防止内存泄漏
    free(temp);
    
    // 5. 返回吃掉的山楂的数据
    return popped;
}

/**
 * 查看栈顶元素 (Peek)
 * 功能: 只看一眼最顶上的山楂是啥，但不要吃掉它
 */
int peek(struct StackNode* root) {
    // 如果串是空的，没得看
    if (isEmpty(root)) {
        printf("栈为空，无法查看 (peek)!\n");
        return INT_MIN;
    }
    // 直接返回顶端山楂的数据
    return root->data;
}

// 主函数：整个程序的入口
int main() {
    // 创建一个栈，最开始是空的，所以“顶端指针”指向 NULL
    struct StackNode* root = NULL;

    printf("--- 开始操作 ---\n");
    push(&root, 10);
    push(&root, 20);
    push(&root, 30);

    printf("\n当前栈顶的元素是: %d\n", peek(root));

    printf("\n开始出栈...\n");
    printf("%d 从栈中弹出 (pop)\n", pop(&root));
    
    printf("现在栈顶的元素是: %d\n", peek(root));
    
    printf("%d 从栈中弹出 (pop)\n", pop(&root));
    printf("%d 从栈中弹出 (pop)\n", pop(&root));
    
    printf("\n尝试从空栈中弹出...\n");
    pop(&root); // 这次会触发 isEmpty 的判断

    return 0;
}

```

#### 预期的输出

运行后，你将看到如下输出，清晰地展示了“后进先出”的过程：

```
--- 开始操作 ---
10 被压入栈 (push)
20 被压入栈 (push)
30 被压入栈 (push)

当前栈顶的元素是: 30

开始出栈...
30 从栈中弹出 (pop)
现在栈顶的元素是: 20
20 从栈中弹出 (pop)
10 从栈中弹出 (pop)

尝试从空栈中弹出...
栈为空，无法出栈 (pop)!
```

#### 代码逐行讲解

*   **`main` 函数**:
    *   `struct StackNode* root = NULL;`：这是故事的开始。我们声明了一个指针叫 `root`，它将永远指向我们糖葫芦串的“顶”。一开始什么都没有，所以它指向 `NULL`（空）。
    *   `push(&root, 10);`：我们调用 `push` 函数。注意，我们传的是 `&root`，也就是 `root` 指针**自己的内存地址**。这是因为 `push` 函数需要**改变** `main` 函数里的这个 `root` 指针，让它指向新的山楂。
    *   `peek(root)`：这里我们只需要传 `root` 本身（存的地址），因为 `peek` 只是“看一眼”，**不会改变** `root` 指针的指向。
    *   `pop(&root)`：和 `push` 一样，`pop` 也要改变 `main` 函数里的 `root` 指针（让它指向下一颗山楂），所以也必须传递 `&root`。

*   **`push(struct StackNode** root, ...)`**:
    *   `**root` 是“指针的指针”，是整个链表实现栈最难理解但最关键的地方。
    *   可以理解为，`main` 函数里的 `root` 是一个写着“顶端山楂地址”的**便签**。
    *   `push` 函数需要修改这张便签上的内容。如果你只把便签上写的地址告诉 `push`，`push` 只能修改地址指向的那个山楂，但无法修改便签本身。
    *   所以 `main` 函数必须把**这张便签放在哪个抽屉里**（`&root`）告诉 `push`，这样 `push` 才能找到这张便签并修改它。
    *   `*root = stackNode;` 这一步，就是通过抽屉地址，找到了那张便签，并把 `stackNode` 的新地址写了上去。

*   **`pop(struct StackNode** root)`**:
    *   原理同 `push`，它也需要修改 `main` 函数里的 `root` 便签。
    *   `temp` 指针是必需的，因为它像一只手，先抓住了要被吃掉的山楂。否则，一旦 `*root = (*root)->next;` 执行（竹签断开），我们就再也找不到那颗旧的山楂了，也就无法 `free` 掉它，造成内存泄漏。

#### 4. 优缺点总结

*   **优点**: **大小动态**。只要内存够，你想加多少就加多少，永不溢出。
*   **缺点**: 每个节点都需要额外空间来存储 `next` 指针，比数组**费一点内存**。