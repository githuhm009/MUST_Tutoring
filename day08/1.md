### 题目精讲

### Project 01, Problem #1: 数组操作

这道题考察的是C语言中最基本的数组操作，包括遍历、扩充、查找、删除和插入。我们一步一步来完成。

假设学生的学号是 `1230012345`，那么需要用到的最后五位是 `1, 2, 3, 4, 5`。

#### 完整代码示例

```c
#include <stdio.h>

// 辅助函数：用来打印数组内容
void print_array(int arr[], int size) {
    printf("[ ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("]\n");
}

int main() {
    printf("--- 问题 1: 数组操作 ---\n\n");

    // ===== (1) 遍历并打印给定数组 =====
    printf("(1) 原始数组:\n");
    int given_array[] = {1, 2, 3, 0, 0};
    int initial_size = 5;
    print_array(given_array, initial_size);
    printf("\n");

    // ===== (2) 建立一个新数组 =====
    printf("(2) 扩展后的新数组:\n");
    int extended_array[10];
    int extended_size = 10;
    
    // 复制旧数组的元素
    for (int i = 0; i < initial_size; i++) {
        extended_array[i] = given_array[i];
    }
    
    // 用学号最后五位初始化后五个元素
    int student_no_suffix[] = {1, 2, 3, 4, 5};
    for (int i = 0; i < 5; i++) {
        extended_array[initial_size + i] = student_no_suffix[i];
    }
    print_array(extended_array, extended_size);
    printf("\n");

    // ===== (3) 在后五个元素中查找最大值 =====
    printf("(3) 查找后五个元素 [1 2 3 4 5] 中的最大值:\n");
    int max_val = -1;
    int max_pos = -1;

    // 我们只关心索引从 5 到 9 的部分
    for (int i = 5; i < 10; i++) {
        if (extended_array[i] > max_val) {
            max_val = extended_array[i];
            max_pos = i + 1; // 题目要求位置(position = index + 1)
        }
    }
    printf("最大元素是 '%d', 它的位置是: %d\n\n", max_val, max_pos);

    // ===== (4) 删除第6个位置的元素 =====
    printf("(4) 删除第6个位置 (索引为5) 的元素 '1':\n");
    // 原始数组: [ 1 2 3 0 0 1 2 3 4 5 ]
    // 要删除的是索引为 5 的 '1'
    
    // 从被删除元素的位置开始，把后面的元素一个个往前挪
    for (int i = 5; i < extended_size - 1; i++) {
        extended_array[i] = extended_array[i + 1];
    }
    extended_size--; // 数组的逻辑大小减 1
    
    printf("删除后的数组: \n");
    print_array(extended_array, extended_size);
    printf("\n");
    
    // ===== (5) 在第6个位置插入元素 '9' =====
    printf("(5) 在第6个位置 (索引为5) 插入元素 '9':\n");
    // 原始数组: [ 1 2 3 0 0 2 3 4 5 ]
    
    // 从数组末尾开始，把元素一个个往后挪，给新元素腾出空间
    extended_size++; // 逻辑大小先加回来
    for (int i = extended_size - 1; i > 5; i--) {
        extended_array[i] = extended_array[i - 1];
    }
    
    // 把 '9' 放入腾出的空位
    extended_array[5] = 9;
    
    printf("插入后的数组: \n");
    print_array(extended_array, extended_size);

    return 0;
}
```

#### 预期输出

```
--- 问题 1: 数组操作 ---

(1) 原始数组:
[ 1 2 3 0 0 ]

(2) 扩展后的新数组:
[ 1 2 3 0 0 1 2 3 4 5 ]

(3) 查找后五个元素 [1 2 3 4 5] 中的最大值:
最大元素是 '5', 它的位置是: 10

(4) 删除第6个位置 (索引为5) 的元素 '1':
删除后的数组: 
[ 1 2 3 0 0 2 3 4 5 ]

(5) 在第6个位置 (索引为5) 插入元素 '9':
插入后的数组: 
[ 1 2 3 0 0 9 2 3 4 5 ]
```
### Project 01, Problem #2: 排序算法

这道题考察的是几种经典的排序算法，并且要求是**降序**排列。

#### 准备工作

首先，我们需要一个数组。题目要求和问题一类似，我们创建一个包含10个元素的数组：`{ 1, 2, 3, 0, 0, 1, 2, 3, 4, 5 }`。

#### 完整代码示例

```c
#include <stdio.h>

// 辅助函数：打印数组
void print_array(int arr[], int size) {
    printf("[ ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("]\n");
}

// (2) 选择排序 (降序)
void selection_sort_desc(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        // 找到从 i 到末尾的最大值的位置
        int max_idx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] > arr[max_idx]) {
                max_idx = j;
            }
        }
        // 把找到的最大值和当前位置交换
        int temp = arr[max_idx];
        arr[max_idx] = arr[i];
        arr[i] = temp;
    }
}

// (3) 插入排序 (降序)
void insertion_sort_desc(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        // 把比 key 小的元素都往后挪
        while (j >= 0 && arr[j] < key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}

// (4) 冒泡排序 (降序)
void bubble_sort_desc(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            // 如果前面的比后面的小，就交换
            if (arr[j] < arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// (5) 快速排序 (降序)
// 辅助函数：分区
int partition_desc(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        // 如果当前元素大于等于 pivot
        if (arr[j] >= pivot) {
            i++;
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;
    return (i + 1);
}

// 快速排序主函数
void quick_sort_desc(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition_desc(arr, low, high);
        quick_sort_desc(arr, low, pi - 1);
        quick_sort_desc(arr, pi + 1, high);
    }
}


int main() {
    printf("--- 问题 2: 排序算法 ---\n\n");
    int original_array[] = {1, 2, 3, 0, 0, 1, 2, 3, 4, 5};
    int n = 10;
    int arr[10];

    // 重置数组的辅助函数
    void reset_array() {
        for(int i=0; i<n; i++) arr[i] = original_array[i];
    }

    printf("原始数组:\n");
    print_array(original_array, n);
    printf("\n");

    // --- (2) 选择排序 ---
    reset_array();
    selection_sort_desc(arr, n);
    printf("(2) 选择排序 (降序) 结果:\n");
    print_array(arr, n);
    printf("\n");

    // --- (3) 插入排序 ---
    reset_array();
    insertion_sort_desc(arr, n);
    printf("(3) 插入排序 (降序) 结果:\n");
    print_array(arr, n);
    printf("\n");

    // --- (4) 冒泡排序 ---
    reset_array();
    bubble_sort_desc(arr, n);
    printf("(4) 冒泡排序 (降序) 结果:\n");
    print_array(arr, n);
    printf("\n");
    
    // --- (5) 快速排序 ---
    reset_array();
    quick_sort_desc(arr, 0, n - 1);
    printf("(5) 快速排序 (降序) 结果:\n");
    print_array(arr, n);
    printf("\n");

    return 0;
}
```

#### 预期输出

```
--- 问题 2: 排序算法 ---

原始数组:
[ 1 2 3 0 0 1 2 3 4 5 ]

(2) 选择排序 (降序) 结果:
[ 5 4 3 3 2 2 1 1 0 0 ]

(3) 插入排序 (降序) 结果:
[ 5 4 3 3 2 2 1 1 0 0 ]

(4) 冒泡排序 (降序) 结果:
[ 5 4 3 3 2 2 1 1 0 0 ]

(5) 快速排序 (降序) 结果:
[ 5 4 3 3 2 2 1 1 0 0 ]
```

### Assignment 02 - 理论与步骤题

这部分是理论知识的考察，需要一步步展示过程。

#### [Question 1]: 树的基本概念

这道题考察对树的术语的理解。我们根据图示来回答。

*   **图示分析**:
    *   这是一个**通用树**，不是二叉树。
    *   `A` 是最顶端的节点。
    *   `G, H, I, P, Q, K, L, M, N` 都没有孩子。

*   **解答**:
    1.  **根节点 (root)?**: `A`
    2.  **叶子节点 (leaves)?**: `G, H, I, P, Q, K, L, M, N`
    3.  **B的父节点 (parent)?**: `A`
    4.  **B的孩子 (children)?**: `D, E`
    5.  **B的兄弟 (siblings)?**: `C, F, G`
    6.  **B的深度 (depth)?**: 根节点A深度为0，所以B的深度为 **1**。
    7.  **B的高度 (height)?**: 从B到其最远叶子节点的路径长度。路径 `B -> E -> J -> P` 或 `B -> E -> J -> Q` 最长，长度为3条边。所以B的高度为 **3**。
    8.  **前序遍历 (Pre-Order: 根-左-右)**: `A, B, D, G, H, E, I, J, P, Q, C, F, K, L, M, N`
    9.  **中序遍历 (In-Order: 左-根-右)**: (对于通用树，一种常见定义是“遍历完第一个子树，访问根，再遍历其他子树”。) `G, D, H, B, I, P, J, Q, E, A, C, K, F, L, M, N`
    10. **后序遍历 (Post-Order: 左-右-根)**: `G, H, D, I, P, Q, J, E, B, C, K, L, M, F, N, A`

#### [Question 2]: AVL树的插入

这道题考察AVL树的插入和旋转操作。我们需要一步步画出插入每个数字后树的形态。

**插入序列: `2, 1, 4, 5, 9, 3, 6, 7`**


    ```markdown
        (4)
       /   \
      (2)   (7)
     / \   / \
    (1) (3)(6) (9)
           /
          (5)
    ```
最终结果如上图所示。


### Assignment 02 
#### [Question 3]: 堆的构建

这道题考察两种构建堆的方法：“自顶向下”（逐个插入）和“自底向上”（批量调整）。

**给定数组: `[2, 5, 8, 3, 4, 7, 1, 9, 12]`**

##### (1) 构建最大堆 - 自顶向下 (Top-Down)

思路：就像我们之前解决Top-K问题时一样，每次插入一个新元素到数组末尾，然后让它“上浮”到正确的位置。

1.  **插入 2**: `[2]`
2.  **插入 5**: `[2, 5]` -> 上浮: `[5, 2]`
3.  **插入 8**: `[5, 2, 8]` -> 上浮: `[8, 2, 5]`
4.  **插入 3**: `[8, 2, 5, 3]` -> (无需上浮)
5.  **插入 4**: `[8, 2, 5, 3, 4]` -> 上浮: `[8, 4, 5, 3, 2]`
6.  **插入 7**: `[8, 4, 5, 3, 2, 7]` -> 上浮: `[8, 4, 7, 3, 2, 5]`
7.  **插入 1**: `[8, 4, 7, 3, 2, 5, 1]` -> (无需上浮)
8.  **插入 9**: `[8, 4, 7, 3, 2, 5, 1, 9]` -> 上浮: `[9, 8, 7, 4, 2, 5, 1, 3]`
9.  **插入 12**: `[9, 8, 7, 4, 2, 5, 1, 3, 12]` -> 上浮: `[12, 9, 7, 4, 8, 5, 1, 3, 2]`

**最终最大堆 (数组表示)**: `[12, 9, 7, 4, 8, 5, 1, 3, 2]`

##### (2) 构建最小堆 - 自顶向下 (Top-Down)

思路：与上面完全相反，每次插入新元素，如果它比父节点小，就“上浮”。

1.  **插入 2**: `[2]`
2.  **插入 5**: `[2, 5]`
3.  **插入 8**: `[2, 5, 8]`
4.  **插入 3**: `[2, 5, 8, 3]` -> 上浮: `[2, 3, 8, 5]`
5.  **插入 4**: `[2, 3, 8, 5, 4]`
6.  **插入 7**: `[2, 3, 8, 5, 4, 7]`
7.  **插入 1**: `[2, 3, 8, 5, 4, 7, 1]` -> 上浮: `[1, 3, 2, 5, 4, 7, 8]`
8.  **插入 9**: `[1, 3, 2, 5, 4, 7, 8, 9]`
9.  **插入 12**: `[1, 3, 2, 5, 4, 7, 8, 9, 12]`

**最终最小堆 (数组表示)**: `[1, 3, 2, 5, 4, 7, 8, 9, 12]`

##### (3) 构建最大堆 - 自底向上 (Bottom-Up)

思路：这是更高效的批量建堆方法。
1.  先把整个数组看成一个“不合格”的完全二叉树。
2.  从**最后一个非叶子节点**开始，向前逐个进行“向下调整”（`heapify`）操作。
    *   数组大小 n = 9。最后一个非叶子节点索引是 `(n/2) - 1 = (9/2) - 1 = 4 - 1 = 3`。
    *   初始数组: `[2, 5, 8, 3, 4, 7, 1, 9, 12]`

3.  **对索引3 (值为3) 进行 `heapify`**:
    *   子节点是`9`和`12`。`12`最大，与`3`交换。
    *   数组变为: `[2, 5, 8, 12, 4, 7, 1, 9, 3]`

4.  **对索引2 (值为8) 进行 `heapify`**:
    *   子节点是`7`和`1`。`8`是最大的，不动。
    *   数组: `[2, 5, 8, 12, 4, 7, 1, 9, 3]`

5.  **对索引1 (值为5) 进行 `heapify`**:
    *   子节点是`12`和`4`。`12`最大，与`5`交换。
    *   数组变为: `[2, 12, 8, 5, 4, 7, 1, 9, 3]`
    *   交换后，`5`在索引3的位置，它的子节点`9`和`3`都比它小，不用再调整。

6.  **对索引0 (值为2) 进行 `heapify`**:
    *   子节点是`12`和`8`。`12`最大，与`2`交换。
    *   数组变为: `[12, 2, 8, 5, 4, 7, 1, 9, 3]`
    *   交换后，`2`在索引1的位置，它的子节点`5`和`4`都比它小，不用再调整。

**最终最大堆 (数组表示)**: `[12, 2, 8, 5, 4, 7, 1, 9, 3]`
*(注意：自底向上和自顶向下构建的结果可能不同，但都满足堆的性质)*

##### (4) 构建最小堆 - 自底向上 (Bottom-Up)

思路：与上面类似，但每次调整都把**最小值**换上来。

*   初始数组: `[2, 5, 8, 3, 4, 7, 1, 9, 12]`

1.  **对索引3 (值为3)**: 子节点`9`, `12`。`3`最小，不动。
2.  **对索引2 (值为8)**: 子节点`7`, `1`。`1`最小，与`8`交换。
    *   数组变为: `[2, 5, 1, 3, 4, 7, 8, 9, 12]`
3.  **对索引1 (值为5)**: 子节点`3`, `4`。`3`最小，与`5`交换。
    *   数组变为: `[2, 3, 1, 5, 4, 7, 8, 9, 12]`
4.  **对索引0 (值为2)**: 子节点`3`, `1`。`1`最小，与`2`交换。
    *   数组变为: `[1, 3, 2, 5, 4, 7, 8, 9, 12]`
    *   交换后，`2`在索引2，它的子节点`8`和`7`都比它大，不用再调整。

**最终最小堆 (数组表示)**: `[1, 3, 2, 5, 4, 7, 8, 9, 12]`

#### [Question 4]: 图的表示

考察邻接矩阵和邻接表两种表示方法。

*   **图分析**:
    *   无向图。
    *   8个顶点 (V1-V8)。
    *   边: (1,2), (1,5), (2,4), (2,5), (3,1), (3,6), (3,7), (4,5), (5,6), (6,8)

##### (1) 邻接矩阵

创建一个 8x8 的矩阵，有边的地方标1，没边的地方标0。因为是无向图，矩阵沿对角线对称。

```
  V1 V2 V3 V4 V5 V6 V7 V8
V1[0, 1, 1, 0, 1, 0, 0, 0]
V2[1, 0, 0, 1, 1, 0, 0, 0]
V3[1, 0, 0, 0, 0, 1, 1, 0]
V4[0, 1, 0, 0, 1, 0, 0, 0]
V5[1, 1, 0, 1, 0, 1, 0, 0]
V6[0, 0, 1, 0, 1, 0, 0, 1]
V7[0, 0, 1, 0, 0, 0, 0, 0]
V8[0, 0, 0, 0, 0, 1, 0, 0]
```

##### (2) 邻接表

创建一个数组，每个元素指向一个链表，链表里是它的邻居。

*   `V1: -> V2 -> V3 -> V5`
*   `V2: -> V1 -> V4 -> V5`
*   `V3: -> V1 -> V6 -> V7`
*   `V4: -> V2 -> V5`
*   `V5: -> V1 -> V2 -> V4 -> V6`
*   `V6: -> V3 -> V5 -> V8`
*   `V7: -> V3`
*   `V8: -> V6`

#### [Question 5]: 图的遍历

考察BFS和DFS的唯一性及具体遍历序列。

*   **图分析**: 无向图 `G`。

##### (1) BFS 和 DFS 结果是否唯一？为什么？

**不唯一。**
*   **原因**: 在遍历过程中，当一个节点有多个未被访问的邻居时，算法**没有规定必须先访问哪个邻居**。你可以按字母顺序访问，也可以按任意其他顺序。选择不同的邻居访问顺序，就会导致最终的遍历序列不同。

##### (2) 从 D 开始的 BFS 遍历

BFS是“一层一层”地遍历。

1.  **第0层**: `D`
2.  **第1层 (D的邻居)**: `A, E, C` (顺序可变, 我们按字母序)
3.  **第2层 (A,E,C的未访问邻居)**:
    *   A的邻居: `B`
    *   E的邻居: `B, G` (B已在考虑中)
    *   C的邻居: `B` (B已在考虑中)
    *   所以是 `B, G`
4.  **第3层 (B,G的未访问邻居)**:
    *   B的邻居: `F`
    *   G的邻居: (无)
    *   所以是 `F`

**一个可能的BFS序列**: `D, A, C, E, B, G, F`

##### (3) 从 D 开始的 DFS 遍历

DFS是“一条路走到黑”。

1.  从 `D` 开始。
2.  去邻居 `A`。
3.  从 `A` 去邻居 `B`。
4.  从 `B` 去邻居 `C`。
5.  从 `C` 只有一个邻居 `D` (已访问)，回溯到 `B`。
6.  从 `B` 去另一个邻居 `E`。
7.  从 `E` 去邻居 `G`。
8.  从 `G` 只有一个邻居 `E` (已访问)，回溯到 `E`。
9.  `E` 的邻居都访问过了，回溯到 `B`。
10. `B` 的邻居都访问过了，回溯到 `A`。
11. `A` 的邻居都访问过了，回溯到 `D`。
12. 从 `D` 去另一个邻居 `F` (这里假设 `F` 也是 `D` 的邻居，虽然图上看不清，但从问题逻辑推断是)。
13. 所有节点访问完毕。

**一个可能的DFS序列**: `D, A, B, C, E, G, F`
*(注意：DFS的可能序列比BFS多得多，因为每个路口的选择都会产生新的分支)*

好的，我们火力全开，继续完成这份大作业的精讲！

### Assignment 02 

#### [Question 6]: 拓扑排序

这道题要求找到一个有向无环图（DAG）的拓扑排序。

*   **思路**: 我们使用**Kahn算法**（基于BFS）。
    1.  计算每个节点的**入度**（有多少箭头指向它）。
    2.  把所有**入度为0**的节点放入一个队列。
    3.  当队列不为空时，执行：
        a. 从队列中取出一个节点 `u`，并将其加入到拓扑排序结果中。
        b. 遍历 `u` 的所有邻居 `v`，并将 `v` 的入度减1。
        c. 如果 `v` 的入度减为0，则将 `v` 放入队列。
    4.  重复直到队列为空。

*   **步骤演示**:
    1.  **计算入度**:
        *   s: 0
        *   A: 1
        *   B: 1
        *   C: 1
        *   D: 2
        *   E: 2
        *   F: 2
        *   G: 1
        *   H: 1
        *   I: 2
        *   t: 2

    2.  **初始化**:
        *   队列: `[s]` (只有 `s` 的入度为0)
        *   结果: `[]`

    3.  **第1轮**:
        *   出队 `s`。结果: `[s]`
        *   `s` 的邻居是 `A` 和 `G`。它们的入度都减1。
        *   A入度变为0，G入度变为0。
        *   将 `A` 和 `G` 入队。队列: `[A, G]` (顺序可变)

    4.  **第2轮**:
        *   出队 `A`。结果: `[s, A]`
        *   `A` 的邻居是 `B`, `D`。它们的入度减1。
        *   B入度变为0, D入度变为1。
        *   `B` 入队。队列: `[G, B]`

    5.  **第3轮**:
        *   出队 `G`。结果: `[s, A, G]`
        *   `G` 的邻居是 `D`, `H`。它们的入度减1。
        *   D入度变为0, H入度变为0。
        *   `D`, `H` 入队。队列: `[B, D, H]`

    6.  ...以此类推...

**一个可能的拓扑排序序列**: `s, G, H, A, D, B, C, E, I, F, t` (注意结果不唯一)

#### [Question 7]: 选择排序

考察选择排序的每一步。思路是：每次都从**未排序**的部分找到**最小**的元素，然后把它放到**已排序**部分的末尾。

*   **序列**: `[29, 72, 98, 13, 87, 66, 52, 51, 36]`

1.  **Pass 1**: 找到最小的 `13`。与 `29` 交换。
    `[13, 72, 98, 29, 87, 66, 52, 51, 36]`
2.  **Pass 2**: 从 `[72, ...]` 中找到最小的 `29`。与 `72` 交换。
    `[13, 29, 98, 72, 87, 66, 52, 51, 36]`
3.  **Pass 3**: 从 `[98, ...]` 中找到最小的 `36`。与 `98` 交换。
    `[13, 29, 36, 72, 87, 66, 52, 51, 98]`
4.  **Pass 4**: 从 `[72, ...]` 中找到最小的 `51`。与 `72` 交换。
    `[13, 29, 36, 51, 87, 66, 52, 72, 98]`
5.  **Pass 5**: 从 `[87, ...]` 中找到最小的 `52`。与 `87` 交换。
    `[13, 29, 36, 51, 52, 66, 87, 72, 98]`
6.  **Pass 6**: 从 `[66, ...]` 中找到最小的 `66`。不动。
    `[13, 29, 36, 51, 52, 66, 87, 72, 98]`
7.  **Pass 7**: 从 `[87, ...]` 中找到最小的 `72`。与 `87` 交换。
    `[13, 29, 36, 51, 52, 66, 72, 87, 98]`
8.  **Pass 8**: 从 `[87, ...]` 中找到最小的 `87`。不动。
    `[13, 29, 36, 51, 52, 66, 72, 87, 98]`
    **排序完成。**

#### [Question 8]: 冒泡排序

思路：像气泡一样，每次都比较相邻的两个元素，如果顺序不对就交换，把大的“冒泡”到后面去。

*   **序列**: `[28, 6, 4, 2, 24]`

1.  **Pass 1**:
    *   `28` > `6` -> `[6, 28, 4, 2, 24]`
    *   `28` > `4` -> `[6, 4, 28, 2, 24]`
    *   `28` > `2` -> `[6, 4, 2, 28, 24]`
    *   `28` > `24` -> `[6, 4, 2, 24, 28]`
2.  **Pass 2**:
    *   `6` > `4` -> `[4, 6, 2, 24, 28]`
    *   `6` > `2` -> `[4, 2, 6, 24, 28]`
    *   `6` < `24` -> (不动)
3.  **Pass 3**:
    *   `4` > `2` -> `[2, 4, 6, 24, 28]`
    *   `4` < `6` -> (不动)
4.  **Pass 4**:
    *   `2` < `4` -> (不动)
    **排序完成。**

#### [Question 9 - 12] (简述思路，因步骤繁琐)

*   **[Q9] 插入排序**: `[3, 1, 4, 1, 5, 9, 2, 6, 5]`
    *   每次从未排序区取一个数，插入到已排序区的正确位置。
    *   `[3]` -> `[1, 3]` -> `[1, 3, 4]` -> `[1, 1, 3, 4]` -> ...

*   **[Q10] 希尔排序**: `[9, 8, 7, 6, 5, 4, 3, 2, 1]` 增量 `{7, 3, 1}`
    1.  **Gap = 7**: 比较 `arr[0]`和`arr[7]`, `arr[1]`和`arr[8]`。
    2.  **Gap = 3**: 进行 3-sort，把数组变成 `[...], arr[i] <= arr[i+3], [...]`
    3.  **Gap = 1**: 最后进行一次普通的插入排序。

*   **[Q11] 快速排序**: `[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]`，pivot是第一个元素 `3`。
    1.  **Partition**: 用两个指针 `i` 和 `j` 从两端向中间扫描，把所有 `<=3` 的放左边，`>3` 的放右边。
    2.  **递归**: 对左右两个子数组重复此过程。

*   **[Q12] 归并排序**: `[3, 1, 4, 1, 5, 9, 2, 6]`
    1.  **分解**: 不断地把数组对半分，直到每个子数组只有一个元素。
        `[3, 1, 4, 1]` 和 `[5, 9, 2, 6]`
        `[3, 1]` `[4, 1]` 和 `[5, 9]` `[2, 6]`
        `[3]` `[1]` `[4]` `[1]` 和 `[5]` `[9]` `[2]` `[6]`
    2.  **合并**: 从最底层的单个元素开始，两两有序地合并。
        `[1, 3]` `[1, 4]` 和 `[5, 9]` `[2, 6]`
        `[1, 1, 3, 4]` 和 `[2, 5, 6, 9]`
        `[1, 1, 2, 3, 4, 5, 6, 9]`


### Assignment 01 - 基础理论与复杂度分析

#### [Question 1-3] (理论概念)

*   **[Q1] 线性/非线性数据结构**:
    *   **线性**: 元素一个接一个排列，像一条线。如数组、链表、栈、队列。
    *   **非线性**: 元素之间是层级或网状关系。如树、图。
    *   **区别**: 线性结构元素间是一对一关系，非线性是一对多或多对多。
    *   **内存**: 数组是**连续(contiguous)**存储；链表是**非连续(non-contiguous)**存储。
*   **[Q2] 求和**:
    *   (1) `Σ(1/4^i)` 是一个**等比数列**求和。`a1=1, q=1/4`。`Sn = a1(1-q^n)/(1-q)`。当 `n->∞`，`Sn = 1/(1-1/4) = 4/3`。
    *   (2) `Σ(i/4^i)` 是一个**错位相减**问题。
*   **[Q3] 数学归纳法**:
    1.  **Base Case**: 证明 `n=1` 时成立。 `Σ(i) = 1`, `(Σi)² = 1`。 `Σ(i³) = 1³ = 1`。成立。
    2.  **Inductive Hypothesis**: 假设 `n=k` 时成立, 即 `(Σi_k)² = Σ(i³_k)`。
    3.  **Inductive Step**: 证明 `n=k+1` 时也成立。需要证明 `(Σi_{k+1})² = Σ(i³_{k+1})`。

#### [Question 4]: 函数增长率排序

考察对 `Big-O` 复杂度的理解。

*   **排序原则**: 常数 < `log(logN)` < `logN` < `√N` < `N` < `N logN` < `N^1.5` < `N^2` < `N² logN` < `N³` < `2^N`
*   **特殊情况**:
    *   `N log(N²) = 2 * N logN`，增长率和 `N logN` 相同。
    *   `N (logN)²` 比 `N logN` 大。
    *   `2^N` 远大于 `2^(N/2)`。
    *   `2/N` 是递减的。
*   **排序结果 (从快到慢)**:
    `2/N` < `37` < `N log(logN)` < `N` < `N logN` ≈ `N log(N²)` < `N(logN)²` < `√N` < `N^1.5` < `N^2` < `N² logN` < `N³` < `2^(N/2)` < `2^N`
    *(注：√N 应该在 N log(logN) 和 N 之间，此处可能有笔误，应为 N > √N)*
    **正确排序**: `2/N < 37 < √N < N log(logN) < N < N logN ≈ N log(N²) < N(logN)² < N^1.5 < ...` *(此处仍需仔细比对 `log` 相关项)*
*   **相同增长率**: `N logN` 和 `N log(N²)`

#### [Question 5-6] (代码复杂度分析)

*   **[Q5] Big-O 分析**:
    1.  单个循环 `n` 次 -> `O(n)`
    2.  两层独立循环 `n*n` -> `O(n²)`
    3.  两层独立循环 `n * n²` -> `O(n³)`
    4.  两层嵌套循环，内层依赖外层 `Σi` -> `O(n²)`
    5.  三层嵌套 `Σ(i²) * Σj` -> `O(n^5)`
    6.  三层嵌套，带 `if`。最坏情况 `if` 恒为真，复杂度同(5)。
*   **[Q6] 算法比较**: `150N logN` vs `N²`。当 `N` 足够大时，`N logN` 的增长率远小于 `N²`，所以程序A运行时间更少。

#### [Question 7-12] (理论概念)

这部分主要考察前面课程的基础知识，如数组/链表选择、栈/队列定义、哈希冲突等，大部分已在之前的讲解中覆盖。

*   **[Q9] 栈操作**:
    `PUSH(10)` -> `PUSH(20)` -> `POP` (弹出**20**) -> `PUSH(10)` -> `PUSH(20)` -> `POP` (弹出**20**) -> `POP` (弹出**10**) -> `POP` (弹出**10**) -> `PUSH(20)` -> `POP` (弹出**20**)。
    **Pop序列**: `20, 20, 10, 10, 20`
*   **[Q12] 哈希表**:
    *   **(1) 分离式连锁**: 冲突的元素用链表挂在后面。
    *   **(2) 线性探测**: 冲突了就往后一个一个找空位。
    *   **(3) 二次探测**: 冲突了就按 `+1², +2², +3²` 的步长找空位。
    *   **(4) 双重哈希**: 冲突了用第二个哈希函数计算步长。