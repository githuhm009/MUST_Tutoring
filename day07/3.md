### 课程项目与作业题目带讲

我们来逐一分析一下老师布置的编程项目（Project）和书面作业（Assignment），看看每个问题到底想让我们做什么，以及如何下手。

### Part 1: 编程项目 01 (Project 01)

这个项目分为两个大问题，都需要用C语言编写完整的程序。

#### 问题 #1：数组操作 (Problem #1: Array)

这个问题是一道“数组体操”，让你一步步地对一个数组进行创建、扩展、查找、删除和插入操作。这是在考察你对C语言数组最基本、最核心的掌控能力。

**假设你的学号最后五位是 `12345`。**

*   **(1) 遍历和打印 (Traverse and print)**
    *   **任务**: 给你一个现成的数组 `array[] = { 1, 2, 3, 0, 0 }`，把它里面的每一个数字都打印出来。
    *   **考点**: 如何使用 `for` 循环来遍历数组。
    *   **思路**: 写一个 `for` 循环，从索引 `0` 到 `4`，依次 `printf` 出 `array[i]` 的值。

*   **(2) 扩展数组 (Extend array)**
    *   **任务**: 创建一个**新的、长度为10**的数组。它的前5个元素是 `{ 1, 2, 3, 0, 0 }`，后5个元素是你的学号后五位 `1, 2, 3, 4, 5`。最终数组应该是 `{ 1, 2, 3, 0, 0, 1, 2, 3, 4, 5 }`。
    *   **考点**: 如何声明一个新数组，并用循环来给它赋值。
    *   **思路**:
        1.  声明一个新数组 `int newArray[10];`
        2.  用一个 `for` 循环把旧数组的5个元素复制到新数组的前5个位置。
        3.  再把你的学号后五位 `1, 2, 3, 4, 5` 依次赋值给新数组的后5个位置（索引`5`到`9`）。

*   **(3) 在子数组中查找最大值 (Search max in subarray)**
    *   **任务**: 在上一步得到的新数组的**最后五个元素**（也就是你的学号 `1, 2, 3, 4, 5`）中，找到最大值（`5`），并打印出它在**整个10元素数组中**的位置（Position = Index + 1）。
    *   **考点**: 如何在数组的一个特定区间内查找最大值。
    *   **思路**:
        1.  初始化 `max_val = -1`, `max_pos = -1`。
        2.  写一个 `for` 循环，**只遍历数组的后半部分**（从索引`5`到`9`）。
        3.  在循环中，比较 `newArray[i]` 和当前的 `max_val`，如果 `newArray[i]` 更大，就更新 `max_val` 和 `max_pos`。
        4.  循环结束后，打印 `max_pos`。对于学号`12345`，最大值`5`在索引`9`，所以位置是`10`。

*   **(4) 删除元素 (Delete element)**
    *   **任务**: 从第(2)步得到的那个10元素数组中，删除**第6个位置**的元素（也就是索引为`5`的元素，值为`1`）。
    *   **考点**: 数组的删除操作，即**后面元素集体前移**。
    *   **思路**:
        1.  目标是删除索引 `5` 的元素。
        2.  写一个 `for` 循环，从索引 `5` 开始，一直到数组的倒数第二个位置（索引`8`）。
        3.  在循环中，执行 `newArray[i] = newArray[i+1];`，也就是让后面的元素覆盖前面的元素。
        4.  操作后，数组逻辑上变短了，现在只有9个有效元素。

*   **(5) 插入元素 (Insert element)**
    *   **任务**: 在第(4)步删除后得到的数组中，在**第6个位置**（索引`5`）插入一个新元素 `9`。
    *   **考点**: 数组的插入操作，即**部分元素集体后移**。
    *   **思路**:
        1.  目标是在索引 `5` 插入`9`。
        2.  为了给新元素腾出空间，需要把从索引`5`开始的所有元素都向后挪一位。
        3.  关键：必须**从后往前**挪！写一个 `for` 循环，从数组的最后一个有效元素开始，一直挪到索引`5`。
        4.  执行 `newArray[i+1] = newArray[i];`
        5.  挪完之后，索引`5`的位置就空出来了，此时执行 `newArray[5] = 9;`。

#### 问题 #2：排序算法 (Problem #2: Sorting Algorithms)

这个问题是考察你对几种经典排序算法的理解和实现能力。

*   **(1) 创建数组 (Establish array)**
    *   **任务**: 和问题一的(2)一样，创建一个包含 `{ 1, 2, 3, 0, 0 }` 和你学号后五位的10元素数组。
    *   **重点**: 你需要为接下来的每一种排序，都**重新创建或者复制**一份这个原始数组。因为排序会改变数组，如果你只用一个，那么只有第一次排序是正确的。

*   **(2) - (5) 实现四种排序算法**
    *   **任务**: 分别用**选择排序、插入排序、冒泡排序、快速排序**，对这个10元素的数组进行**降序**（从大到小）排序。
    *   **考点**: 这四种经典排序算法的C语言实现。
    *   **思路**:
        1.  **选择排序 (Selection Sort)**: 每次都从“未排序”的部分里，**选出最大**的那个，放到“已排序”部分的末尾。
        2.  **插入排序 (Insertion Sort)**: 像打牌时整理手牌一样。每次从未排序部分拿一张牌，然后在已排序部分**找到合适的位置**插进去。
        3.  **冒泡排序 (Bubble Sort)**: 不断地比较**相邻的两个元素**，如果顺序不对就交换。每一轮“冒泡”都会把当前最大的元素“冒”到队尾。
        4.  **快速排序 (Quick Sort)**: 这是最高级的一个。选一个“基准值”(pivot)，然后把数组分成“比基准值小”和“比基准值大”两部分。然后对这两部分**递归地**进行同样的操作。

### Part 2: 书面作业 (Assignments)

这些是理论题目，考察你对数据结构概念和算法过程的理解。

#### Assignment 02 - Question 1 (树的基本术语)

这是一个“看图说话”题，考察你对树的所有基本概念是否清晰。
*   **(1) 根 (root)**: `A`
*   **(2) 叶子 (leaves)**: `G, H, I, L, M, K` (所有没有孩子的节点)
*   **(3) B的父节点 (parent)**: `A`
*   **(4) B的孩子 (children)**: `D, E`
*   **(5) B的兄弟 (siblings)**: `C, F`
*   **(6) B的深度 (depth)**: 从根`A`到`B`有1条边，所以深度是 `1` (假设根深度为0)。
*   **(7) B的高度 (height)**: 从`B`到它最远的叶子（`L`或`M`）有2条边，所以高度是 `2`。
*   **(8) 前序遍历 (Pre-Order: 根-左-右)**: `A, B, D, G, H, E, I, J, L, M, C, F, K`
*   **(9) 中序遍历 (In-Order: 左-根-右)**: `G, D, H, B, I, E, L, J, M, A, C, K, F`
*   **(10) 后序遍历 (Post-Order: 左-右-根)**: `G, H, D, I, L, M, J, E, B, C, K, F, A`

#### Assignment 02 - Question 2 (AVL树插入)

*   **任务**: 将 `2, 1, 4, 5, 9, 3, 6, 7` 依次插入一个空的AVL树。
*   **考点**: AVL树的插入操作，以及**四种旋转**（LL, RR, LR, RL）来恢复平衡。
*   **思路**: 你需要一步一步地画图。每插入一个数，就检查是否破坏了平衡。如果破坏了，判断属于哪种失衡情况，然后执行对应的旋转。这是一个细致活，需要不断练习。

#### Assignment 01 (早期作业回顾)

这些是更基础的理论题。

*   **Question 1**: 线性/非线性数据结构的区别和例子。
    *   **线性**: 元素一个接一个，像一串糖葫芦 (数组, 链表, 栈, 队列)。
    *   **非线性**: 一个元素可以连接多个，像一张蜘蛛网 (树, 图)。

*   **Question 4**: 函数增长率排序 (大O)。
    *   **考点**: 对`log N`, `N`, `N log N`, `N²`, `2^N` 等常见增长率的熟悉程度。
    *   **关键**: `log N` 长得最慢，`2^N` 长得最快。`N log(N^2)` 等于 `2 * N log N`，它和 `N log N` 是同阶的。

*   **Question 5**: 时间复杂度分析。
    *   **(1)** 单层循环 -> `O(n)`
    *   **(2)** 两层独立循环 -> `O(n*n) = O(n²)`
    *   **(3)** 两层独立循环，内层是`n*n` -> `O(n * n²) = O(n³)`
    *   **(4)** 两层嵌套，内层循环依赖外层(`j < i`) -> `O(n²)` (这是一个等差数列求和)
    *   **(5)** 三层嵌套 -> `O(n^5)`
    *   **(6)** 复杂嵌套，需要仔细分析 `if` 条件的影响。