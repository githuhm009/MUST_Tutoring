### 第八章带讲：图和图算法

**我们的地图（贯穿全文的示例图）**

这是一张包含6个城市（A, B, C, D, E, F）和一些道路的地图。道路旁的数字代表“公里数”（权重）。

```markdown
      (A)------7------(B)
     / |              |
    5  |              9
   /   |              |
 (C)---8----(D)      (F)
   \   |   /          |
    7  |  6           11
     \ | /            |
      (E)-------------
```

---

#### 1. 如何在电脑里“画”这张地图？

我们将使用**邻接矩阵**来表示这张地图，因为它在代码实现上更直观。

```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h> // for INT_MAX

#define V 6 // 我们地图里有6个城市 (A=0, B=1, C=2, D=3, E=4, F=5)

// 邻接矩阵表示法
// graph[i][j] = 0 表示 i 和 j 之间没有直达的路
// graph[i][j] > 0 表示 i 和 j 之间路的长度
int graph[V][V] = {
    // A, B, C, D, E, F
    { 0, 7, 5, 0, 0, 0 }, // A 的邻居
    { 7, 0, 0, 0, 0, 9 }, // B 的邻居
    { 5, 0, 0, 8, 7, 0 }, // C 的邻居
    { 0, 0, 8, 0, 6, 0 }, // D 的邻居
    { 0, 0, 7, 6, 0, 11}, // E 的邻居
    { 0, 9, 0, 0, 11, 0}  // F 的邻居
};
```

---

#### 2. 图的遍历：游客如何逛遍所有城市

##### A. 广度优先搜索 (BFS) - “稳扎稳打”策略

游客从城市 `A` (索引 `0`) 出发。

*   **核心工具**: 一个**队列** (先进先出) 和一个 `visited` 数组 (记录去过的地方)。
*   **步骤**:
    1.  **出发**: 访问 `A`，把 `A` 放入队列。
        *   访问顺序: `[A]`
        *   队列: `[A]`
    2.  **第一圈**: 从队列取出 `A`。把 `A` 所有**未访问过**的邻居 (`B`, `C`) 加入队列。
        *   访问顺序: `[A]`
        *   队列: `[B, C]`
    3.  **第二圈 (处理B)**: 从队列取出 `B`。把 `B` 所有**未访问过**的邻居 (`F`) 加入队列。
        *   访问顺序: `[A, B]`
        *   队列: `[C, F]`
    4.  **第二圈 (处理C)**: 从队列取出 `C`。把 `C` 所有**未访问过**的邻居 (`D`, `E`) 加入队列。
        *   访问顺序: `[A, B, C]`
        *   队列: `[F, D, E]`
    5.  ...继续这个过程，直到队列为空。

*   **C语言代码实现**:
    ```c
    void BFS(int startVertex) {
        int visited[V] = {0}; // 0 表示未访问, 1 表示已访问
        int queue[V];
        int front = 0, rear = 0;

        printf("BFS 遍历顺序: ");

        // 1. 从起点开始
        visited[startVertex] = 1;
        printf("%c ", startVertex + 'A');
        queue[rear++] = startVertex;

        // 2. 当队列不为空
        while (front != rear) {
            // 2.1 从队列头取出一个城市
            int u = queue[front++];

            // 2.2 遍历这个城市的所有邻居
            for (int v = 0; v < V; v++) {
                // 如果有路，并且邻居没去过
                if (graph[u][v] != 0 && !visited[v]) {
                    visited[v] = 1;
                    printf("%c ", v + 'A');
                    queue[rear++] = v; // 把邻居加入队列
                }
            }
        }
        printf("\n");
    }
    ```

##### B. 深度优先搜索 (DFS) - “一条路走到黑”策略

游客同样从城市 `A` (索引 `0`) 出发。

*   **核心工具**: **递归** (利用函数调用栈) 和一个 `visited` 数组。
*   **步骤**:
    1.  **出发**: 访问 `A`。
    2.  **前进**: 从 `A` 的邻居中随便找一个没去过的，比如 `B`。**立刻**前往 `B` 并访问它。
    3.  **再前进**: 从 `B` 的邻居中找一个没去过的，`F`。**立刻**前往 `F` 并访问它。
    4.  **死胡同**: `F` 的邻居 `B` 和 `E`，`B`去过了。假设我们接下来检查 `E`，立刻前往 `E`。
    5.  **回溯**: `E` 的所有邻居都去过了，无路可走。**返回**到上一个城市 `F`。`F` 也没有别的路了，**返回**到`B`。`B`也没有别的路了，**返回**到`A`。
    6.  **另一条路**: 回到 `A` 后，发现还有一个邻居 `C` 没去过。于是从 `A` 前往 `C`，开始新的探索。

*   **C语言代码实现**:
    ```c
    void DFS_helper(int u, int visited[]) {
        visited[u] = 1;
        printf("%c ", u + 'A');

        for (int v = 0; v < V; v++) {
            if (graph[u][v] != 0 && !visited[v]) {
                DFS_helper(v, visited); // 递归调用，一路向前
            }
        }
    }

    void DFS(int startVertex) {
        int visited[V] = {0};
        printf("DFS 遍历顺序: ");
        DFS_helper(startVertex, visited);
        printf("\n");
    }
    ```

---

#### 3. 图算法：游客的“高级任务”

##### A. 最短路径：Dijkstra 算法 - “贪心导航仪”

任务：找到从 `A` (起点) 到所有其他城市的最短驾车距离。

*   **核心工具**:
    *   `dist[]` 数组：记录从起点 `A` 到各个城市的**暂定**最短距离。
    *   `sptSet[]` 数组 (Shortest Path Tree Set)：一个布尔数组，记录哪些城市**已经找到了最终的**最短距离。

*   **步骤演示**:
    1.  **初始化**:
        *   `dist` = `[0, INF, INF, INF, INF, INF]` (只有到自己是0，其他无穷远)
        *   `sptSet` = `[F, F, F, F, F, F]` (F=False, T=True)

    2.  **第一轮**:
        *   从未确定集合中，选一个`dist`最小的城市。那就是 `A` (`dist[A]=0`)。
        *   将 `A` 加入 `sptSet`。`sptSet` = `[T, F, F, F, F, F]`。
        *   **更新邻居**: 经由 `A`，到 `B` 的距离是 `7`，到 `C` 的距离是 `5`。更新 `dist` 数组。
        *   `dist` = `[0, 7, 5, INF, INF, INF]`。

    3.  **第二轮**:
        *   从未确定集合 `(B,C,D,E,F)` 中，选 `dist` 最小的。那就是 `C` (`dist[C]=5`)。
        *   将 `C` 加入 `sptSet`。`sptSet` = `[T, F, T, F, F, F]`。
        *   **更新邻居**:
            *   经由 `C`，到 `D` 的距离是 `5 + 8 = 13`。更新`dist[D]`。
            *   经由 `C`，到 `E` 的距离是 `5 + 7 = 12`。更新`dist[E]`。
        *   `dist` = `[0, 7, 5, 13, 12, INF]`。

    4.  ...重复这个过程，直到所有城市都加入 `sptSet`。

*   **C语言代码实现**:
    ```c
    int minDistance(int dist[], int sptSet[]) {
        int min = INT_MAX, min_index;
        for (int v = 0; v < V; v++) {
            if (sptSet[v] == 0 && dist[v] <= min) {
                min = dist[v], min_index = v;
            }
        }
        return min_index;
    }

    void dijkstra(int src) {
        int dist[V];
        int sptSet[V];

        for (int i = 0; i < V; i++) {
            dist[i] = INT_MAX;
            sptSet[i] = 0;
        }
        dist[src] = 0;

        for (int count = 0; count < V - 1; count++) {
            int u = minDistance(dist, sptSet);
            sptSet[u] = 1;
            for (int v = 0; v < V; v++) {
                if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {
                    dist[v] = dist[u] + graph[u][v];
                }
            }
        }

        printf("Dijkstra 算法结果 (从 %c 出发):\n", src + 'A');
        for (int i = 0; i < V; i++) {
            printf("到 %c 的最短距离: %d\n", i + 'A', dist[i]);
        }
    }
    ```

##### B. 最小生成树：Prim 算法 - “滚雪球”

任务：用最少的光缆（总长度最小）把所有6个城市连接起来。

*   **核心工具**:
    *   `key[]` 数组：记录“未联网”城市到“已联网”区域的最短距离。
    *   `mstSet[]` 数组：记录哪些城市已经加入了我们的网络。

*   **步骤演示**:
    1.  **初始化**:
        *   `key` = `[0, INF, INF, INF, INF, INF]`
        *   `mstSet` = `[F, F, F, F, F, F]`
        *   从 `A` 开始。

    2.  **第一轮**:
        *   选择 `A` 加入网络。 `mstSet` = `[T, F, F, F, F, F]`。
        *   **更新邻居**: `A` 的邻居是 `B(7)` 和 `C(5)`。更新它们到“已联网”区域的 `key` 值。
        *   `key` = `[0, 7, 5, INF, INF, INF]`。

    3.  **第二轮**:
        *   从未联网城市中，选一个 `key` 值最小的。那就是 `C` (`key[C]=5`)。
        *   将 `C` 和连接它的那条 `A-C` 边加入我们的方案。
        *   将 `C` 加入网络。 `mstSet` = `[T, F, T, F, F, F]`。
        *   **更新邻居**: `C` 的邻居 `D(8)` 和 `E(7)` 都是未联网的。更新它们的 `key` 值。
            *   `key[D]` 变成 `8`。
            *   `key[E]` 变成 `7`。
            *   `B` 的 `key` 值 `7` 保持不变。
        *   `key` = `[0, 7, 5, 8, 7, INF]`。

    4.  ...重复这个过程，直到所有城市都加入网络。

*   **C语言代码实现**:
    ```c
    // (minKey 函数和 dijkstra 的 minDistance 类似)
    int minKey(int key[], int mstSet[]) {
        int min = INT_MAX, min_index;
        for (int v = 0; v < V; v++)
            if (mstSet[v] == 0 && key[v] < min)
                min = key[v], min_index = v;
        return min_index;
    }

    void primMST() {
        int parent[V]; // 记录MST的结构
        int key[V];
        int mstSet[V];

        for (int i = 0; i < V; i++) {
            key[i] = INT_MAX;
            mstSet[i] = 0;
        }

        key[0] = 0;
        parent[0] = -1; // 第一个节点是根

        for (int count = 0; count < V - 1; count++) {
            int u = minKey(key, mstSet);
            mstSet[u] = 1;
            for (int v = 0; v < V; v++) {
                if (graph[u][v] && mstSet[v] == 0 && graph[u][v] < key[v]) {
                    parent[v] = u;
                    key[v] = graph[u][v];
                }
            }
        }

        printf("Prim 算法找到的最小生成树 (MST):\n");
        printf("边   \t权重\n");
        int total_weight = 0;
        for (int i = 1; i < V; i++) {
            printf("%c - %c \t%d \n", parent[i] + 'A', i + 'A', graph[i][parent[i]]);
            total_weight += graph[i][parent[i]];
        }
        printf("总成本: %d\n", total_weight);
    }
    ```

#### `main` 函数

最后，提供一个 `main` 函数来调用所有这些功能：

```c
int main() {
    printf("--- 图的遍历 ---\n");
    BFS(0);
    DFS(0);
    printf("\n");

    printf("--- 最短路径算法 ---\n");
    dijkstra(0);
    printf("\n");

    printf("--- 最小生成树算法 ---\n");
    primMST();
    
    return 0;
}
```