### Top-K 问题

#### 1. 问题是什么？

**通俗来讲**：想象你是一个教练，眼前有**一大堆（n个）**水平参差不齐的选手，他们的战斗力都写在头顶上。你的任务是，从这群人里找出**战斗力最强的那 k 个**选手。

例如 (PPT P52)：
*   选手列表 `nums`: `[1, 7, 6, 3, 2]` (n=5)
*   你的任务 `k`: `3`
*   最终结果：你要找出 `[7, 6, 3]` 这三位最强的选手（顺序无所谓）。

#### 2. 解法一：“笨办法” - 擂台海选 (PPT P52)

这是最符合直觉，但效率最低的方法。

*   **思路**:
    1.  **第一轮**: 你让所有 `n` 个选手上台打一遍，找出战斗力最高的那个（`7`）。你把他请下台，让他去休息区。
    2.  **第二轮**: 你让**剩下**的 `n-1` 个选手再打一遍，找出其中最强的那个（`6`）。你也把他请到休息区。
    3.  **第三轮**: 你让**再剩下**的 `n-2` 个选手打一遍，找出最强的（`3`）。
    4.  ... 重复这个过程 `k` 轮。

*   **评价**:
    *   **优点**: 简单粗暴，容易理解。
    *   **缺点**: **极其慢！** 如果有100万个选手，你要找Top 100，这个过程会慢得无法接受。它的时间复杂度是 `O(n*k)`。

#### 过程演示

**第1轮：选出 Top 1**

1.  把所有选手 `[1, 7, 6, 3, 2]` 都叫上场。
2.  他们互相比较，最终发现 `7` 是最强的。
3.  记录下 `7`，然后让他去休息区。
4.  **已选出**: `[7]`
5.  **剩余选手**: `[1, 6, 3, 2]`

**第2轮：选出 Top 2**

1.  把**剩下**的选手 `[1, 6, 3, 2]` 叫上场。
2.  他们互相比较，发现 `6` 是最强的。
3.  记录下 `6`，让他也去休息区。
4.  **已选出**: `[7, 6]`
5.  **剩余选手**: `[1, 3, 2]`

**第3轮：选出 Top 3**

1.  把最后剩下的选手 `[1, 3, 2]` 叫上场。
2.  他们互相比较，发现 `3` 是最强的。
3.  记录下 `3`。
4.  **已选出**: `[7, 6, 3]`
5.  **任务完成**: 我们已经选出了3个人，可以收工了。

#### C语言代码示例 (解法一)

为了实现“选出后就让他去休息区”这个逻辑，我们可以在找到最大值后，将其替换为一个非常非常小的值（比如 `INT_MIN`），这样它在下一轮就不会再被选中了。

```c
#include <stdio.h>
#include <stdlib.h> // for malloc
#include <limits.h> // for INT_MIN

void findTopK_solution1(int nums[], int n, int k) {
    if (k <= 0 || k > n) {
        printf("k值无效\n");
        return;
    }

    // 创建一个原始数组的副本，以免修改原数组
    int* temp_nums = (int*)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) {
        temp_nums[i] = nums[i];
    }
    
    // 用来存放结果
    int* top_k_elements = (int*)malloc(k * sizeof(int));

    printf("--- 开始“擂台海选”法 ---\n");

    // 进行 k 轮海选
    for (int i = 0; i < k; i++) {
        int max_val = INT_MIN; // 当前轮的最大值
        int max_idx = -1;      // 当前轮最大值的位置

        // 在所有“还在场上”的选手中，找到最强者
        for (int j = 0; j < n; j++) {
            if (temp_nums[j] > max_val) {
                max_val = temp_nums[j];
                max_idx = j;
            }
        }
        
        // 记录下本轮选出的冠军
        top_k_elements[i] = max_val;
        printf("第 %d 轮: 选出最强者 %d\n", i + 1, max_val);
        
        // 让他“下场休息”，方法是把他的战斗力改成一个极小值
        if (max_idx != -1) {
            temp_nums[max_idx] = INT_MIN;
        }
    }

    printf("\n--- 海选结束 ---\n");
    printf("最终选出的 Top %d 选手是: ", k);
    for (int i = 0; i < k; i++) {
        printf("%d ", top_k_elements[i]);
    }
    printf("\n");

    free(temp_nums);
    free(top_k_elements);
}

int main() {
    int nums[] = {1, 7, 6, 3, 2};
    int n = sizeof(nums) / sizeof(nums[0]);
    int k = 3;
    
    findTopK_solution1(nums, n, k);
    return 0;
}
```

##### 预期输出

```
--- 开始“擂台海选”法 ---
第 1 轮: 选出最强者 7
第 2 轮: 选出最强者 6
第 3 轮: 选出最强者 3

--- 海选结束 ---
最终选出的 Top 3 选手是: 7 6 3 
```


#### 3. 解法二：“用力过猛”法 - 全员大排名 (PPT P53)

这个方法比上一个聪明，但做了一些“多余”的工作。

*   **思路**:
    1.  你觉得一轮一轮海选太麻烦了。干脆，你组织一场盛大的“武林大会”，让所有 `n` 个选手都决出名次，从第1名到第 `n` 名，全部排好序。
    2.  排序结束后，你直接把**最后面的那 `k` 个人**（也就是战斗力最高的 `k` 个人）挑出来就行了。

*   **评价**:
    *   **优点**: 思路清晰，代码好写（一个 `sort` 函数就搞定）。
    *   **缺点**: 用力过猛 (Overkill)！你的任务只是找出“最强的3个人”，你根本不关心第4名到第 `n` 名他们内部是怎么排序的。但排序算法却把所有人的名次都排好了，做了很多你不需要的额外工作。它的时间复杂度是 `O(n log n)`。

#### 过程演示

**第1步：全员排序**

1.  把所有选手 `[1, 7, 6, 3, 2]` 都叫来。
2.  组织一场“武林大会”（比如用快速排序算法），把他们从弱到强排成一队。
3.  **排序后的队伍**: `[1, 2, 3, 6, 7]`

**第2步：录取最后k名**

1.  队伍已经排好了，你只需要从队尾开始，把最后 `k` (3) 个人叫出来就行。
2.  他们分别是 `7`, `6`, `3`。
3.  **任务完成**。

#### C语言代码示例 (解法二)

在C语言中，我们可以使用标准库 `<stdlib.h>` 中的 `qsort` 函数来快速实现排序。

```c
#include <stdio.h>
#include <stdlib.h> // for malloc and qsort

// 这是 qsort 函数需要的一个比较函数
// 它告诉 qsort 如何比较两个整数
int compare_integers(const void* a, const void* b) {
    return (*(int*)a - *(int*)b);
}

void findTopK_solution2(int nums[], int n, int k) {
    if (k <= 0 || k > n) {
        printf("k值无效\n");
        return;
    }

    // 创建一个副本进行排序
    int* sorted_nums = (int*)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) {
        sorted_nums[i] = nums[i];
    }
    
    printf("--- 开始“全员大排名”法 ---\n");
    printf("原始选手列表: [1, 7, 6, 3, 2]\n");

    // 1. 全员排序 (从小到大)
    qsort(sorted_nums, n, sizeof(int), compare_integers);
    
    printf("排序后的结果: [");
    for(int i=0; i<n; i++) printf("%d ", sorted_nums[i]);
    printf("]\n");

    // 2. 直接从数组末尾取出 k 个元素
    int* top_k_elements = (int*)malloc(k * sizeof(int));
    printf("\n录取最后 %d 名选手...\n", k);
    
    for (int i = 0; i < k; i++) {
        top_k_elements[i] = sorted_nums[n - 1 - i];
    }
    
    printf("\n--- 排名结束 ---\n");
    printf("最终选出的 Top %d 选手是: ", k);
    for (int i = 0; i < k; i++) {
        printf("%d ", top_k_elements[i]);
    }
    printf("\n");

    free(sorted_nums);
    free(top_k_elements);
}

int main() {
    int nums[] = {1, 7, 6, 3, 2};
    int n = sizeof(nums) / sizeof(nums[0]);
    int k = 3;
    
    findTopK_solution2(nums, n, k);
    return 0;
}
```

##### 预期输出

```
--- 开始“全员大排名”法 ---
原始选手列表: [1, 7, 6, 3, 2]
排序后的结果: [1 2 3 6 7 ]

录取最后 3 名选手...

--- 排名结束 ---
最终选出的 Top 3 选手是: 7 6 3 
```

#### 4. 解法三：“精明高效”法 - 维持一个“准入擂台” (PPT P54-P63)

这是本章的**精髓**，也是解决 Top-K 问题的**最优解**。

*   **思路**:
    你设立一个只能容纳 **`k` 个人**的“精英擂台”。这个擂台有个神奇的规则：**战斗力最低的人永远站在擂台门口**。

    我们用 `k=3` 来模拟这个过程：

    1.  **步骤一：先填满擂台**
        *   你先从选手列表里随便叫**前 `k` (3) 个**人上台。他们是 `[1, 7, 6]`。
        *   擂台的魔法自动生效，战斗力最低的 `1` 被安排站在了门口。
        *   **擂台现状**: `[1, 7, 6]` (门口是 `1`)
        *   **图示**:
            ```markdown
                 (1) <-- 门口 (堆顶)
                /   \
              (7)   (6)
            ```

    2.  **步骤二：遍历剩下的人，决定谁有资格“挑战”**
        *   **下一个选手 `3` 号上场**:
            *   你让他和站在门口的 `1` 号比一下。`3 > 1`，说明新来的选手比擂台上最弱的人要强！
            *   **挑战发生**: `1` 号被一脚踹下擂台，`3` 号成功上台。
            *   擂台魔法再次生效，自动把**新的最弱者**安排到门口。
            *   **擂台现状**: `[3, 7, 6]` (门口现在是 `3`)
            *   **图示**:
                ```markdown
                     (3) <-- 门口
                    /   \
                  (7)   (6)
                ```

        *   **最后一个选手 `2` 号上场**:
            *   你让他和站在门口的 `3` 号比。`2 < 3`，说明他还不如擂台上最弱的人。
            *   **挑战失败**: `2` 号没有资格上台，直接淘汰。
            *   **擂台现状**: `[3, 7, 6]` (没变)

    3.  **最终结果**:
        *   所有选手都过了一遍，现在还留在擂台上的 `[3, 7, 6]`，就是你要找的战斗力最强的那3个人！

*   **这个“精英擂台”是什么？**
    *   它就是我们的最小堆 (Min-Heap)！
    *   **为什么是最小堆？** 因为我们的策略是“**不断淘汰当前 `k` 个候选人里最弱的那个**”。最小堆的堆顶永远是最小值，可以让我们**瞬间 (`O(1)`)** 知道谁是“最弱的”，从而做出高效的判断。

*   **评价**:
    *   **优点**: **最高效！** 它只对所有元素遍历一次，每次比较和调整的代价都很小。时间复杂度是 `O(n log k)`，当 `k` 远小于 `n` 时，它约等于 `O(n)`，非常快。
    *   **缺点**: 思路比前两种稍微复杂一点。

### C语言完整代码实现 (Top-K最优解)

```c
#include <stdio.h>
#include <stdlib.h>

// 交换两个整数
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

/**
 * 最小堆的“向下调整”函数
 * arr: 堆的数组表示
 * size: 堆的大小
 * index: 从哪个节点开始调整
 */
void heapify(int arr[], int size, int index) {
    int smallest = index;      // 假设当前节点是最小的
    int left = 2 * index + 1;  // 左孩子的索引
    int right = 2 * index + 2; // 右孩子的索引

    // 如果左孩子存在，并且比当前“最小”还小
    if (left < size && arr[left] < arr[smallest]) {
        smallest = left;
    }
    // 如果右孩子存在，并且比当前“最小”还小
    if (right < size && arr[right] < arr[smallest]) {
        smallest = right;
    }

    // 如果最小的不是自己，说明需要调整
    if (smallest != index) {
        swap(&arr[index], &arr[smallest]);
        // 交换后，可能会影响下面的子树，所以要递归地向下调整
        heapify(arr, size, smallest);
    }
}

/**
 * 解决 Top-K 问题的函数
 * nums: 原始选手列表
 * numsSize: 总人数 n
 * k: 要找的人数 k
 */
void findTopK(int nums[], int numsSize, int k) {
    if (k <= 0 || k > numsSize) {
        printf("k值无效\n");
        return;
    }

    // 1. 建立我们的“精英擂台”（一个大小为k的最小堆）
    // 先把前k个元素放进来
    int* heap = (int*)malloc(k * sizeof(int));
    for (int i = 0; i < k; i++) {
        heap[i] = nums[i];
    }
    
    // 把这个初始的、无序的擂台整理成一个合格的最小堆
    // 从最后一个非叶子节点开始，向前逐个进行“向下调整”
    for (int i = (k / 2) - 1; i >= 0; i--) {
        heapify(heap, k, i);
    }

    printf("--- 开始筛选 ---\n");
    printf("初始擂台 (最小堆): ");
    for(int i=0; i<k; i++) printf("%d ", heap[i]);
    printf(" (门口站的是: %d)\n", heap[0]);


    // 2. 遍历剩下的人 (从第 k+1 个到最后一个)
    for (int i = k; i < numsSize; i++) {
        printf("\n选手 %d 上场, 准备挑战门口的 %d...\n", nums[i], heap[0]);
        // 如果新选手比擂台上最弱的（门口的）还强
        if (nums[i] > heap[0]) {
            printf("挑战成功！ %d 被淘汰, %d 上台。\n", heap[0], nums[i]);
            // 踹掉最弱的，换上新来的
            heap[0] = nums[i];
            // 新人上台后，擂台需要重新整理，确保最弱的再次来到门口
            heapify(heap, k, 0);
        } else {
            printf("挑战失败！ %d 不够强。\n", nums[i]);
        }
        printf("当前擂台: ");
        for(int j=0; j<k; j++) printf("%d ", heap[j]);
        printf(" (门口站的是: %d)\n", heap[0]);
    }

    printf("\n--- 筛选结束 ---\n");
    printf("最终留在擂台上的 Top %d 选手是: ", k);
    for (int i = 0; i < k; i++) {
        printf("%d ", heap[i]);
    }
    printf("\n");

    free(heap);
}

int main() {
    int nums[] = {1, 7, 6, 3, 2};
    int n = sizeof(nums) / sizeof(nums[0]);
    int k = 3;

    findTopK(nums, n, k);

    return 0;
}
```

### 预期输出

```
--- 开始筛选 ---
初始擂台 (最小堆): 1 7 6  (门口站的是: 1)

选手 3 上场, 准备挑战门口的 1...
挑战成功！ 1 被淘汰, 3 上台。
当前擂台: 3 7 6  (门口站的是: 3)

选手 2 上场, 准备挑战门口的 3...
挑战失败！ 2 不够强。
当前擂台: 3 7 6  (门口站的是: 3)

--- 筛选结束 ---
最终留在擂台上的 Top 3 选手是: 3 7 6 
```