# 算法的时空复杂度分析

在自动化和嵌入式系统中，我们不仅关心算法能否得到正确的结果，更关心它**执行得有多快**（时间）以及它**消耗了多少内存**（空间）。时空复杂度分析就是衡量这两项指标的通用语言。

我们通常使用“大O表示法”（Big O Notation）来描述复杂度。它表示算法的执行时间或空间消耗随数据规模（`n`）增长的变化趋势。

## 时间复杂度 (Time Complexity)

时间复杂度衡量的是算法的执行时间随输入数据规模 `n` 增大的增长趋势。

### 1. O(1) - 常数时间复杂度

这是最理想的复杂度。算法的执行时间不随输入数据 `n` 的大小而改变。

**C语言示例：** 读取单个传感器的值。无论你有10个传感器还是100个，读取其中 *某一个* 的操作耗时都是固定的。

```c
#include <stdbool.h>

// 假设这是一个寄存器地址，直接读取即可获得传感器的状态
#define SENSOR_STATUS_REGISTER 0x40021000 

// 检查急停按钮是否被按下
bool is_emergency_stop_pressed() {
    // 直接从内存映射的硬件地址读取状态
    // 这是一个单一步骤的操作，与系统多复杂无关
    unsigned int status = *( (volatile unsigned int*) SENSOR_STATUS_REGISTER );
    return (status & 0x01); // 假设第0位是急停标志位
}
```

*   **自动化视角**: `O(1)` 是实时控制系统的目标。例如，安全保护逻辑（如急停）必须在常数时间内完成，以确保最快的响应速度。

### 2. O(n) - 线性时间复杂度

算法的执行时间与输入数据规模 `n` 成线性关系。`n` 增大一倍，耗时也约增大一倍。

**C语言示例：** 计算多个传感器读数的平均值。你需要遍历所有 `n` 个传感器的读数。

```c
// 计算一组传感器读数的平均值
// n 是传感器的数量 (数组的大小)
float calculate_average(int sensor_readings[], int n) {
    float sum = 0.0;
    
    // 循环将执行 n 次
    for (int i = 0; i < n; i++) {
        sum += sensor_readings[i];
    }
    
    return sum / n;
}
```

*   **自动化视角**: `O(n)` 在数据处理中非常常见。比如对一个缓冲区的数据进行滤波处理。你需要清楚地知道 `n` 的最大值是多少，以确保最坏情况下的执行时间也能满足系统的实时性要求。

### 3. O(n²) - 平方时间复杂度

算法的执行时间与 `n` 的平方成正比。`n` 增大一倍，耗时约增大四倍。这种复杂度的算法在 `n` 较大时会变得非常慢。

**C语言示例：** 使用冒泡排序对传感器数据进行排序（这是一种简单但效率较低的排序算法）。

```c
// 使用冒泡排序对传感器数据进行排序
// n 是数据的数量
void bubble_sort(int data[], int n) {
    // 外层循环执行 n-1 次
    for (int i = 0; i < n - 1; i++) {
        // 内层循环在最坏情况下也执行约 n 次
        for (int j = 0; j < n - i - 1; j++) {
            if (data[j] > data[j+1]) {
                // 交换元素
                int temp = data[j];
                data[j] = data[j+1];
                data[j+1] = temp;
            }
        }
    }
}
```
*   **自动化视角**: 在实时系统中必须极力避免 `O(n²)` 或更高阶的算法。想象一下，如果一个视觉检测系统需要处理的像素点 `n` 很大，一个 `O(n²)` 的算法可能会导致处理一帧图像的时间远超生产线的节拍，造成漏检。

### 4. O(log n) - 对数时间复杂度

这是非常高效的复杂度。当 `n` 翻倍时，耗时仅仅增加一个固定的量。典型的例子是二分查找。

**C语言示例：** 在一个已排序的故障代码表中快速查找某个代码的含义。

```c
// 在一个已排序的故障代码数组中查找目标代码
// codes: 已排序的故障代码数组
// n: 数组大小
// target_code: 要查找的代码
int binary_search(int codes[], int n, int target_code) {
    int low = 0, high = n - 1;
    
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (codes[mid] == target_code) {
            return mid; // 找到了，返回索引
        } else if (codes[mid] < target_code) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1; // 没找到
}
```
*   **自动化视角**: `O(log n)` 非常适合在大量的配置参数或固定的数据表中进行快速查找，能显著提升系统的响应速度和效率。

## 空间复杂度 (Space Complexity)

空间复杂度衡量的是算法运行过程中临时占用的存储空间随数据规模 `n` 增大的增长趋势。在内存极其有限的MCU上，这一点尤为重要。

### 1. O(1) - 常数空间复杂度

算法需要的内存空间是固定的，不随 `n` 的大小而变化。

**C语言示例：** 上面计算平均值的 `calculate_average` 函数，无论数组有多大，它都只需要额外的一个 `sum` 变量和一个 `i` 变量。

### 2. O(n) - 线性空间复杂度

算法需要的内存空间与 `n` 成线性关系。

**C语言示例：** 创建一个输入数组的完整拷贝。

```c
#include <stdlib.h> // for malloc

// 创建并返回一个输入数组的拷贝
int* create_copy(int original_array[], int n) {
    // 需要分配 n 个整数大小的内存空间
    int* copy_array = (int*)malloc(n * sizeof(int));
    
    for (int i = 0; i < n; i++) {
        copy_array[i] = original_array[i];
    }
    
    return copy_array;
}
```

*   **自动化视角**: `O(n)` 的空间复杂度在资源受限的设备上需要特别小心。如果 `n` 代表一个高分辨率图像的像素点，`O(n)` 的内存申请可能会直接导致内存溢出（Stack Overflow / Out of Memory）。

## 总结

| 复杂度 | 名称 | 性能 | 自动化系统中的例子 |
| :--- | :--- | :--- | :--- |
| **O(1)** | 常数 | 极好 | 读取单个IO口状态、执行一次PID计算 |
| **O(log n)**| 对数 | 优秀 | 在已排序的参数表中查找数据 |
| **O(n)** | 线性 | 良好 | 遍历传感器数据数组、对信号进行简单滤波 |
| **O(n²)** | 平方 | 差 | 效率低的排序算法、简单的图像像素点两两比较 |
| **O(2ⁿ)** | 指数 | 极差 | （通常在嵌入式中应完全避免） |

**核心思想**：在满足功能需求的前提下，始终选择时间和空间复杂度尽可能低的算法，尤其是在为实时性要求高、计算资源有限的自动化系统编写代码时。