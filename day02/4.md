# 第三章带讲：链表核心概念解析

这份讲义是对 `Lecture 03: Lists` 的核心内容回顾与重点解析。我们将跳过基础定义，直击C语言实现链表时最关键、也最容易出错的几个环节，帮助你深刻理解其底层工作原理。

## 1. 核心思想：为什么需要链表？它与数组的根本区别

我们已经学过数组，它用起来很简单。为什么还需要链表这么复杂的东西？

*   **数组的痛点**: 数组最大的问题在于它是**静态的、连续的**。
    1.  **大小固定**: 在定义 `int arr[100];` 时，你就锁定了100个整数的空间，多了浪费，少了不够用。
    2.  **插入/删除困难**: 想象一下，在一个排好队的数组中间要插入一个新人，他后面的所有人都得往后挪一个位置。同样，一个人走了，他后面的所有人都要往前补位。这个“挪动”的操作在数据量大时非常耗时（时间复杂度 `O(n)`）。

*   **链表的解决方案**: 链表的设计思想就是为了解决这两个痛点。
    1.  **动态大小**: 链表的节点是在需要时才通过 `malloc` 创建的，用一个加一个，不用了就 `free` 掉，非常灵活。
    2.  **高效插入/删除**: 链表的节点在内存中是**散装**的，彼此靠一个`next`指针连接。想在中间插入一个节点？我们只需要改变前后两个节点的指针指向即可，不需要移动任何其他节点。这个操作本身极快（时间复杂度 `O(1)`）。

> **一句话总结**: 数组像**电影院的连排座位**（整齐但不好加塞），链表像**餐厅里的零散座位**（随便坐，靠服务员手里的单子串联起来）。

---

## 2. C语言的实现核心：`struct`，指针 和 `malloc`

PPT第6页的节点定义是理解一切的基础。

```c
struct Node {
    int data;            // 数据域：存放我们关心的数据，比如传感器读数
    struct Node* next;   // 指针域：这是链表的灵魂！
};
```

学生最困惑的就是 `struct Node* next;` 这一行。它的意思是：
**“在这个叫 `Node` 的结构体里面，有一个成员叫 `next`，它是一个指针，这个指针专门用来存放另一个 `Node` 结构体的内存地址。”**

这就是“节点”能“链接”起来的根本原因。

而 `createNode()` 函数里的 `malloc(sizeof(struct Node))` 则是在**堆内存 (Heap)** 中动态申请一块刚好能装下一个 `Node` 结构体的空间。这块空间就是你的新节点，`malloc` 会返回这块空间的地址，你需要用一个 `Node` 指针去接住它。

---

## 3. 最容易出错的操作：插入和删除的指针逻辑

这是整个章节的重中之重，也是面试和考试的必考点。写错一步，整个链表就会“断掉”或者部分节点“丢失”。

### 插入操作（在`current`节点后插入`newNode`）

假设我们想把 `newNode` 插入到 `current` 和 `current->next` 之间。

**错误的顺序**:
1.  `current->next = newNode;`  // 先让current指向新节点
2.  `newNode->next = ???;`      // 坏了！current原来指向的那个节点的地址已经丢了！

**正确的顺序永远是“先连后，再连前”**:

```c
// 1. 先把新节点的 "next" 指针设置好，让它指向 current 原本指向的下一个节点
//    这一步是“继承”链接关系，保证链表不会断裂。
newNode->next = current->next;

// 2. 然后，再把 current 节点的 "next" 指针，指向我们的新节点。
//    这一步是把新节点“接入”到链表中。
current->next = newNode;
```
**记住这个顺序，就不会出错。**

### 删除操作（删除`current`节点后面的节点）

假设我们要删除 `current` 节点**后面**的那个节点。

1.  **首先，需要一个临时指针保存要删除的节点**，否则一旦修改了链接，就再也找不到它了，会导致内存泄漏。
    ```c
    struct Node* nodeToDelete = current->next;
    ```
2.  **然后，执行“跨越”操作**，让 `current` 的 `next` 指针直接指向“下下个”节点，从而“跳过”要被删除的节点。
    ```c
    // 关键一步：让 current 的 next 指向 nodeToDelete 的 next
    current->next = nodeToDelete->next;
    ```
3.  **最后，释放被“孤立”的节点的内存**。
    ```c
    free(nodeToDelete);
    ```

---

## 4. 特殊情况：为什么要单独处理“头部”？

在插入和删除的函数中，你总会看到一个 `if (position == 1)` 或 `if (head == ...)` 的判断。这是因为**对链表头部的操作是特殊的**。

*   `head` 指针是整个链表的唯一入口。它不是一个普通的节点，而是指向第一个节点的指针变量。
*   当你在**任何其他位置**插入或删除时，你改变的是某个节点的 `next` 指针。
*   但当你在**头部**插入或删除时，你改变的是`head` 指针本身的值。

**例如，在头部插入一个 `newNode`**:
`newNode` 需要成为新的第一个节点，所以 `head` 必须指向 `newNode`。
```c
newNode->next = head; // 新节点的next指向旧的head
head = newNode;      // head指针现在指向新节点
```
因为 `head` 变量的值被改变了，所以处理头节点的函数通常需要返回**新的 `head` 指针**。

---

## 5. 复杂度辨析：插入/删除到底是 O(1) 还是 O(n)？

PPT里同时提到了 `O(1)` 和 `O(n)`，这可能会让人困惑。

*   **`O(1)` 指的是纯粹的“指针修改”操作**。如果我们已经拿到了指向前一个节点（比如 `current`）的指针，那么执行上面讲的插入或删除操作，只需要固定的两三步，这不随链表长度变化，所以是 `O(1)`。
*   **`O(n)` 指的是一个完整的“按位置插入/删除”函数**。这个函数通常需要一个 `for` 或 `while` 循环，从 `head` 开始遍历，找到目标位置。这个“寻找”的过程是 `O(n)` 的。

> **结论**: 链表的优势在于，一旦你**定位**了操作点，后续的**执行**是 `O(1)` 的。而数组的 `O(n)` 成本则是在**执行**阶段（移动元素）。