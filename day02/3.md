# 朴素模式匹配算法 (Naive String Matching)

模式匹配是这样一个问题：给定一个主字符串 `T` (Text) 和一个模式字符串 `P` (Pattern)，在主字符串 `T` 中寻找模式字符串 `P` 第一次出现的位置。

朴素模式匹配算法是解决这个问题最直接、最暴力的方法。它的核心思想非常简单：**将模式 `P` 逐一地与主字符串 `T` 的所有子串进行比较。**

## 算法思想

想象我们有两把尺子，一把长尺子（主字符串 `T`）和一把短尺子（模式 `P`）。

1.  **对齐**: 将短尺子 `P` 对齐到长尺子 `T` 的最左端（索引 `0`）。
2.  **比较**: 从左到右，逐一比较短尺子上的刻度（字符）和长尺子上对应的刻度是否完全一样。
    *   **如果完全一样**: 恭喜，我们找到了一个匹配。算法结束，返回当前 `T` 的起始索引。
    *   **如果中途遇到不匹配**: 说明当前位置不是一个成功的匹配。
3.  **滑动**: 将短尺子 `P` 向右滑动一个位置。
4.  **重复**: 回到第 2 步，继续比较，直到 `P` 滑动到 `T` 的末尾都找不到匹配。

## C语言代码实现

让我们用C语言来实现这个算法。我们将编写一个函数 `naive_search()`，它返回模式 `P` 在 `T` 中首次出现的索引，如果找不到则返回 `-1`。

```c
#include <stdio.h>
#include <string.h>

/**
 * @brief 使用朴素模式匹配算法在文本中查找模式。
 * 
 * @param text 主字符串 (Haystack)
 * @param pattern 要查找的模式字符串 (Needle)
 * @return int 模式第一次出现的索引，如果未找到则返回 -1。
 */
int naive_search(const char *text, const char *pattern) {
    size_t n = strlen(text);
    size_t m = strlen(pattern);

    // 如果模式比文本还长，不可能找到匹配
    if (m > n) {
        return -1;
    }

    // 外层循环：控制滑动的起始位置 i
    // i 只需遍历到 n - m 即可，因为再往后剩余的文本长度已不足以容纳模式
    for (size_t i = 0; i <= n - m; i++) {
        size_t j;

        // 内层循环：在当前起始位置 i，逐一比较模式中的每个字符
        for (j = 0; j < m; j++) {
            // 如果在任何一点发生不匹配，立即中断内层循环
            if (text[i + j] != pattern[j]) {
                break;
            }
        }

        // 如果内层循环是因为成功完成（j 增长到了 m）而退出的
        // 这意味着所有字符都匹配了
        if (j == m) {
            return i; // 找到了匹配，返回起始索引 i
        }
    }

    // 如果外层循环结束后仍然没有返回，说明没有找到任何匹配
    return -1;
}

int main() {
    const char *device_log = "INFO: System boot. TEMP: 35C. STATUS: OK.";
    const char *pattern1 = "STATUS";
    const char *pattern2 = "ERROR";
    const char *pattern3 = "boot";

    int index1 = naive_search(device_log, pattern1);
    int index2 = naive_search(device_log, pattern2);
    int index3 = naive_search(device_log, pattern3);

    printf("在 '%s' 中查找:\n", device_log);

    if (index1 != -1) {
        printf("- 模式 '%s' 在索引 %d 处找到。\n", pattern1, index1);
    } else {
        printf("- 模式 '%s' 未找到。\n", pattern1);
    }

    if (index2 != -1) {
        printf("- 模式 '%s' 在索引 %d 处找到。\n", pattern2, index2);
    } else {
        printf("- 模式 '%s' 未找到。\n", pattern2);
    }

    if (index3 != -1) {
        printf("- 模式 '%s' 在索引 %d 处找到。\n", pattern3, index3);
    } else {
        printf("- 模式 '%s' 未找到。\n", pattern3);
    }

    return 0;
}
```

### 程序输出
```
在 'INFO: System boot. TEMP: 35C. STATUS: OK.' 中查找:
- 模式 'STATUS' 在索引 32 处找到。
- 模式 'ERROR' 未找到。
- 模式 'boot' 在索引 13 处找到。
```

## 复杂度分析

*   **时间复杂度**:
    *   **最坏情况**: `O(m * (n-m+1))` 或简化为 `O(m*n)`。
        *   这种情况发生在每次比较都几乎成功，直到最后一个字符才失败。例如：主字符串 `T` = "AAAA...AAB"，模式 `P` = "AAB"。
    *   **最好情况**: `O(m)`。
        *   如果第一次比较就找到了匹配。

*   **空间复杂度**: `O(1)`。
    *   我们只用了几个额外的变量（`i`, `j`, `n`, `m`）来存储索引和长度，所需空间是固定的，不随字符串长度的增加而增加。

## 优缺点与应用

**优点**:
*   **简单直观**：算法逻辑清晰，极易理解和实现。
*   **无需预处理**：不需要对主串或模式串进行任何复杂的预计算。

**缺点**:
*   **效率低下**：在最坏情况下，性能很差。它包含了很多冗余的比较。例如，当比较失败时，它只是简单地将模式向右移动一位，而没有利用上一次比较得到的信息。

**自动化工程视角**:
*   **适用场景**: 对于在嵌入式系统中处理长度较短的、一次性的字符串匹配任务（例如，解析一个短的AT命令，或者在LCD菜单项中查找关键字），朴素算法因为其简单性和低内存占用，通常是**足够好**的选择。
*   **不适用场景**: 如果你需要处理高速、大量的流式数据（例如，从网络摄像头视频流中识别特定模式，或是在高速总线数据中进行协议解析），朴素算法的 `O(m*n)` 复杂度会成为性能瓶颈。在这种情况下，就需要采用更高级的算法，如 **KMP** 或 **Boyer-Moore**。