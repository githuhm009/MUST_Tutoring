# C语言中的字符串基本操作

C语言本身没有内置的 "string" 类型，我们通过操作以 `\0` 结尾的字符数组来处理字符串。标准库 `<string.h>` 提供了一套丰富的函数来完成常见的字符串操作。

> **⚠️ 安全第一：缓冲区溢出警告**
> C语言的字符串函数有一个共性：它们不检查目标缓冲区的大小。如果你试图将一个很长的字符串复制到一个很小的字符数组中，就会发生**缓冲区溢出 (Buffer Overflow)**。这不仅会破坏内存中的其他数据，导致程序崩溃，也是一个严重的安全漏洞。
> **最佳实践**：始终使用这些函数的“安全”版本（通常带有 `n` 后缀，如 `strncpy`），它们允许你指定最大操作长度。


## 1. 获取字符串长度 - `strlen()`

*   **函数**: `size_t strlen(const char *str);`
*   **功能**: 计算字符串 `str` 中的字符数，直到遇到第一个 `\0` 为止，**不包括 `\0` 本身**。`size_t` 是一种无符号整数类型。

### 自动化场景示例
在通过串口接收到一个控制命令后，首先检查其长度是否在预期范围内。

```c
#include <stdio.h>
#include <string.h>

int main() {
    // 假设从串口接收到以下命令
    const char *command = "SET_SPEED:1024";
    size_t len = strlen(command);

    printf("命令 '%s' 的长度是: %zu\n", command, len); // %zu 是 size_t 的格式说明符

    if (len > 32) {
        printf("错误: 命令过长!\n");
    } else {
        printf("命令长度合法。\n");
    }
    return 0;
}
// 输出:
// 命令 'SET_SPEED:1024' 的长度是: 15
// 命令长度合法。
```


## 2. 复制字符串 - `strcpy()` 和 `strncpy()`

*   **不安全函数**: `char *strcpy(char *dest, const char *src);`
*   **安全函数**: `char *strncpy(char *dest, const char *src, size_t n);`
*   **功能**: 将源字符串 `src` 复制到目标缓冲区 `dest`。

### 示例
将一个固定的状态信息复制到一个用于LCD显示的缓冲区中。

```c
#include <stdio.h>
#include <string.h>

int main() {
    char lcd_buffer; // 假设LCD一行能显示16个字符 + 1个'\0'
    const char *status_ok = "System OK";
    const char *status_long = "Error: Sensor Overload Failure";

    // 安全地复制 "System OK"
    strncpy(lcd_buffer, status_ok, sizeof(lcd_buffer) - 1);
    lcd_buffer[sizeof(lcd_buffer) - 1] = '\0'; // 确保字符串以'\0'结尾
    printf("LCD 显示: %s\n", lcd_buffer);

    // 尝试复制一个过长的字符串
    strncpy(lcd_buffer, status_long, sizeof(lcd_buffer) - 1);
    lcd_buffer[sizeof(lcd_buffer) - 1] = '\0'; // 再次确保安全
    printf("LCD 显示: %s\n", lcd_buffer);

    return 0;
}
// 输出:
// LCD 显示: System OK
// LCD 显示: Error: Sensor O
```

> **注意**: `strncpy` 有个特点：如果源字符串长度大于或等于 `n`，它**不会**在末尾自动添加 `\0`。因此，最佳实践是手动在缓冲区最后一位设置为 `\0`。


## 3. 连接字符串 - `strcat()` 和 `strncat()`

*   **不安全函数**: `char *strcat(char *dest, const char *src);`
*   **安全函数**: `char *strncat(char *dest, const char *src, size_t n);`
*   **功能**: 将源字符串 `src` **追加**到目标字符串 `dest` 的末尾。`dest` 必须有足够的空间容纳两个字符串。

### 示例
构建一个发送给上位机的日志字符串。

```c
#include <stdio.h>
#include <string.h>

int main() {
    char log_message = "EVENT: ";
    const char *event_type = "Motor Stopped. ";
    const char *reason = "Reason Code: E5.";

    // 连接事件类型
    strncat(log_message, event_type, sizeof(log_message) - strlen(log_message) - 1);
    
    // 连接原因
    strncat(log_message, reason, sizeof(log_message) - strlen(log_message) - 1);

    printf("完整日志: %s\n", log_message);
    return 0;
}
// 输出:
// 完整日志: EVENT: Motor Stopped. Reason Code: E5.
```

## 4. 比较字符串 - `strcmp()`

*   **函数**: `int strcmp(const char *s1, const char *s2);`
*   **功能**: 比较两个字符串 `s1` 和 `s2`。
    *   如果 `s1 == s2`，返回 `0`。
    *   如果 `s1 < s2`（按字典序），返回一个**负数**。
    *   如果 `s1 > s2`，返回一个**正数**。

### 示例
判断接收到的命令是否是 "START"。

```c
#include <stdio.h>
#include <string.h>

void process_command(const char *cmd) {
    if (strcmp(cmd, "START") == 0) {
        printf("接收到 START 命令，启动电机。\n");
    } else if (strcmp(cmd, "STOP") == 0) {
        printf("接收到 STOP 命令，停止电机。\n");
    } else {
        printf("未知命令: %s\n", cmd);
    }
}

int main() {
    process_command("START");
    process_command("stop"); // 注意：strcmp 区分大小写
    return 0;
}
// 输出:
// 接收到 START 命令，启动电机。
// 未知命令: stop
```

## 5. 查找字符 - `strchr()`

*   **函数**: `char *strchr(const char *str, int c);`
*   **功能**: 在字符串 `str` 中查找字符 `c` **第一次出现**的位置。如果找到，返回一个指向该字符的指针；如果没找到，返回 `NULL`。

### 示例
解析键值对格式的数据，如 ` "TEMP=45.2" `。

```c
#include <stdio.h>
#include <string.h>

int main() {
    char data[] = "TEMP=45.2";
    char *separator = strchr(data, '=');

    if (separator != NULL) {
        // separator 指向 '=', 那么 separator + 1 就指向值的开始
        char *value_str = separator + 1;
        printf("找到了分隔符 '='。\n");
        printf("键是 'TEMP'，值是 '%s'。\n", value_str);
    } else {
        printf("数据格式不正确。\n");
    }
    return 0;
}
// 输出:
// 找到了分隔符 '='。
// 键是 'TEMP'，值是 '45.2'。
```


## 6. 查找子字符串 - `strstr()`

*   **函数**: `char *strstr(const char *haystack, const char *needle);`
*   **功能**: 在字符串 `haystack` (草堆) 中查找子字符串 `needle` (针) **第一次出现**的位置。如果找到，返回指向子字符串起始位置的指针；如果没找到，返回 `NULL`。

### 示例
在设备返回的一长串信息中，检查是否包含 "ERROR" 关键字。

```c
#include <stdio.h>
#include <string.h>

int main() {
    const char *device_response = "Status: OK, Temp: 35C, Voltage: 5.0V";
    const char *error_response = "Status: ERROR, Code: 101, Temp: 99C";

    if (strstr(device_response, "ERROR") != NULL) {
        printf("响应 1 中包含错误!\n");
    } else {
        printf("响应 1 正常。\n");
    }
    
    if (strstr(error_response, "ERROR") != NULL) {
        printf("响应 2 中包含错误!\n");
    }
    return 0;
}
// 输出:
// 响应 1 正常。
// 响应 2 中包含错误!
```

---

## 7. 分割字符串 - `strtok()`

*   **函数**: `char *strtok(char *str, const char *delim);`
*   **功能**: 一个强大的函数，用于将字符串 `str` 按 `delim` 中的分隔符分解成一系列“标记”(tokens)。
*   **警告**: `strtok` 会**修改原始字符串**（用 `\0` 替换分隔符），并且它使用一个内部静态变量来记住上次的位置，这意味着它**不是线程安全的**，在同一个函数中也不能同时用它分割两个不同的字符串。

### 示例
解析来自GPS模块的逗号分隔（CSV）数据。

```c
#include <stdio.h>
#include <string.h>

int main() {
    // 原始字符串必须是可修改的字符数组
    char gps_data[] = "GPRMC,123519,A,4807.038,N,01131.000,E,022.4,084.4,230394,003.1,W*6A";
    const char *delimiter = ",";

    // 第一次调用，传入字符串
    char *token = strtok(gps_data, delimiter);

    printf("GPS 数据各字段:\n");
    while (token != NULL) {
        printf("  %s\n", token);
        // 后续调用，传入 NULL，继续从上次的位置分割
        token = strtok(NULL, delimiter);
    }
    return 0;
}
// 输出:
// GPS 数据各字段:
//   GPRMC
//   123519
//   A
//   4807.038
//   N
//   ... (等等)
```